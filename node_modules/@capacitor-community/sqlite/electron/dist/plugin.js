'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var require$$0 = require('sqlite3');
var require$$0$1 = require('path');
var require$$1 = require('fs');
var require$$2 = require('os');
var require$$3 = require('jszip');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);
var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$2__default = /*#__PURE__*/_interopDefaultLegacy(require$$2);
var require$$3__default = /*#__PURE__*/_interopDefaultLegacy(require$$3);

var src = {};

var Database$1 = {};

var exportToJson = {};

var utilsSQLite = {};

Object.defineProperty(utilsSQLite, "__esModule", { value: true });
utilsSQLite.UtilsSQLite = void 0;
class UtilsSQLite {
    constructor() {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        //    this.JSQlite = require('@journeyapps/sqlcipher').verbose();
        this.SQLite3 = require$$0__default['default'];
    }
    /**
     * OpenOrCreateDatabase
     * @param pathDB
     * @param password
     */
    async openOrCreateDatabase(pathDB /*,
    password: string,*/) {
        const msg = 'OpenOrCreateDatabase: ';
        // open sqlite3 database
        /*    const mDB: any = new this.JSQlite.Database(pathDB, {
          verbose: console.log,
        });
        */
        const mDB = new this.SQLite3.Database(pathDB, {
            verbose: console.log,
        });
        if (mDB != null) {
            try {
                await this.dbChanges(mDB);
            }
            catch (err) {
                return Promise.reject(msg + `dbChanges ${err}`);
            }
            try {
                /*        // set the password
                if (password.length > 0) {
                  await this.setCipherPragma(mDB, password);
                }
        */
                // set Foreign Keys On
                await this.setForeignKeyConstraintsEnabled(mDB, true);
                // Check Version
                const curVersion = await this.getVersion(mDB);
                if (curVersion === 0) {
                    await this.setVersion(mDB, 1);
                }
            }
            catch (err) {
                return Promise.reject(msg + `${err}`);
            }
            return Promise.resolve(mDB);
        }
        else {
            return Promise.reject(msg + 'open database failed');
        }
    }
    /**
     * SetCipherPragma
     * @param mDB
     * @param password
     */
    /*
    public async setCipherPragma(mDB: any, password: string): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`, (err: any) => {
            if (err) {
              reject(new Error('SetForeignKey: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * SetForeignKeyConstraintsEnabled
     * @param mDB
     * @param toggle
     */
    async setForeignKeyConstraintsEnabled(mDB, toggle) {
        return new Promise((resolve, reject) => {
            let key = 'OFF';
            if (toggle) {
                key = 'ON';
            }
            mDB.run(`PRAGMA foreign_keys = '${key}'`, (err) => {
                if (err) {
                    reject(`SetForeignKey: ${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * GetVersion
     * @param mDB
     */
    async getVersion(mDB) {
        return new Promise((resolve, reject) => {
            let version = 0;
            const SELECT_VERSION = 'PRAGMA user_version;';
            mDB.get(SELECT_VERSION, [], (err, row) => {
                // process the row here
                if (err) {
                    reject('getVersion failed: ' + `${err.message}`);
                }
                else {
                    if (row == null) {
                        version = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        version = row[key];
                    }
                    resolve(version);
                }
            });
        });
    }
    /**
     * SetVersion
     * @param mDB
     * @param version
     */
    async setVersion(mDB, version) {
        return new Promise((resolve, reject) => {
            mDB.run(`PRAGMA user_version = ${version}`, (err) => {
                if (err) {
                    reject('setVersion failed: ' + `${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * ChangePassword
     * @param pathDB
     * @param password
     * @param newpassword
     */
    /*
  
    public async changePassword(
      pathDB: string,
      password: string,
      newpassword: string,
    ): Promise<void> {
      let mDB: any;
      try {
        mDB = await this.openOrCreateDatabase(pathDB, password);
        await this.pragmaReKey(mDB, password, newpassword);
      } catch (err) {
        return Promise.reject(err);
      } finally {
        mDB.close();
      }
    }
  */
    /**
     * PragmaReKey
     * @param mDB
     * @param password
     * @param newpassword
     */
    /*
    private async pragmaReKey(
      mDB: any,
      password: string,
      newpassword: string,
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        mDB.serialize(() => {
          mDB.run('PRAGMA cipher_compatibility = 4');
          mDB.run(`PRAGMA key = '${password}'`);
          mDB.run(`PRAGMA rekey = '${newpassword}'`, (err: any) => {
            if (err) {
              reject(new Error('ChangePassword: ' + `${err.message}`));
            }
            resolve();
          });
        });
      });
    }
  */
    /**
     * BeginTransaction
     * @param db
     * @param isOpen
     */
    async beginTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'BeginTransaction: ';
            if (!isOpen) {
                return Promise.reject(`${msg}database not opened`);
            }
            const sql = 'BEGIN TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * RollbackTransaction
     * @param db
     * @param isOpen
     */
    async rollbackTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'RollbackTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'ROLLBACK TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * CommitTransaction
     * @param db
     * @param isOpen
     */
    async commitTransaction(db, isOpen) {
        return new Promise((resolve, reject) => {
            const msg = 'CommitTransaction: ';
            if (!isOpen) {
                reject(`${msg}database not opened`);
            }
            const sql = 'COMMIT TRANSACTION;';
            db.run(sql, (err) => {
                if (err) {
                    reject(`${msg}${err.message}`);
                }
                resolve();
            });
        });
    }
    /**
     * DbChanges
     * return total number of changes
     * @param db
     */
    async dbChanges(db) {
        return new Promise((resolve, reject) => {
            const SELECT_CHANGE = 'SELECT total_changes()';
            let changes = 0;
            db.get(SELECT_CHANGE, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`DbChanges failed: ${err.message}`);
                }
                else {
                    if (row == null) {
                        changes = 0;
                    }
                    else {
                        const key = Object.keys(row)[0];
                        changes = row[key];
                    }
                    resolve(changes);
                }
            });
        });
    }
    /**
     * GetLastId
     * @param db
     */
    getLastId(db) {
        return new Promise((resolve, reject) => {
            const SELECT_LAST_ID = 'SELECT last_insert_rowid()';
            let lastId = -1;
            db.get(SELECT_LAST_ID, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetLastId failed: ${err.message}`);
                }
                else {
                    if (row == null)
                        resolve(lastId);
                    const key = Object.keys(row)[0];
                    lastId = row[key];
                    resolve(lastId);
                }
            });
        });
    }
    /**
     * Execute
     * @param mDB
     * @param sql
     */
    async execute(mDB, sql) {
        let changes = -1;
        let initChanges = -1;
        try {
            initChanges = await this.dbChanges(mDB);
            await this.execDB(mDB, sql);
            changes = (await this.dbChanges(mDB)) - initChanges;
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(`Execute: ${err.message}`);
        }
    }
    /**
     * ExecDB
     * @param mDB
     * @param sql
     */
    async execDB(mDB, sql) {
        return new Promise((resolve, reject) => {
            mDB.exec(sql, async (err) => {
                if (err) {
                    reject(`Execute: ${err.message}: `);
                }
                resolve();
            });
        });
    }
    /**
     * ExecuteSet
     * @param db
     * @param set
     */
    async executeSet(db, set) {
        let lastId = -1;
        for (let i = 0; i < set.length; i++) {
            const statement = 'statement' in set[i] ? set[i].statement : null;
            const values = 'values' in set[i] && set[i].values.length > 0 ? set[i].values : [];
            if (statement == null) {
                let msg = 'ExecuteSet: Error Nostatement';
                msg += ` for index ${i}`;
                return Promise.reject(msg);
            }
            try {
                if (Array.isArray(values[0])) {
                    for (const val of values) {
                        lastId = await this.prepareRun(db, statement, val);
                    }
                }
                else {
                    lastId = await this.prepareRun(db, statement, values);
                }
            }
            catch (err) {
                return Promise.reject(`ExecuteSet: ${err}`);
            }
        }
        return Promise.resolve(lastId);
    }
    /**
     * PrepareRun
     * @param db
     * @param statement
     * @param values
     */
    prepareRun(db, statement, values) {
        return new Promise((resolve, reject) => {
            let lastId = -1;
            db.run(statement, values, async (err) => {
                if (err) {
                    reject(`PrepareRun: run ${err.message}`);
                }
                else {
                    try {
                        lastId = await this.getLastId(db);
                        resolve(lastId);
                    }
                    catch (err) {
                        reject(`PrepareRun: lastId ${err}`);
                    }
                }
            });
        });
    }
    /**
     * QueryAll
     * @param mDB
     * @param sql
     * @param values
     */
    queryAll(mDB, sql, values) {
        return new Promise((resolve, reject) => {
            mDB.serialize(() => {
                mDB.all(sql, values, (err, rows) => {
                    if (err) {
                        reject(`QueryAll: ${err.message}`);
                    }
                    else {
                        if (rows == null) {
                            rows = [];
                        }
                        resolve(rows);
                    }
                });
            });
        });
    }
}
utilsSQLite.UtilsSQLite = UtilsSQLite;

var utilsJson = {};

Object.defineProperty(utilsJson, "__esModule", { value: true });
utilsJson.UtilsJson = void 0;
const utilsSQLite_1$5 = utilsSQLite;
class UtilsJson {
    constructor() {
        this._uSQLite = new utilsSQLite_1$5.UtilsSQLite();
    }
    /**
     * IsTableExists
     * @param db
     * @param isOpen
     * @param tableName
     */
    async isTableExists(db, isOpen, tableName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isTableExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='table' AND name='${tableName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isTableExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * IsViewExists
     * @param db
     * @param isOpen
     * @param viewName
     */
    async isViewExists(db, isOpen, viewName) {
        return new Promise((resolve, reject) => {
            if (!isOpen) {
                reject('isViewExists: database not opened');
            }
            let query = 'SELECT name FROM sqlite_master WHERE ';
            query += `type='view' AND name='${viewName}';`;
            db.all(query, [], (err, rows) => {
                // process the row here
                if (err) {
                    reject(`isViewExists: failed: ${err.message}`);
                }
                else {
                    if (rows.length === 0) {
                        resolve(false);
                    }
                    else {
                        resolve(true);
                    }
                }
            });
        });
    }
    /**
     * CreateSchema
     * @param mDB
     * @param jsonData
     */
    async createSchema(mDB, jsonData) {
        // create the database schema
        let changes = 0;
        try {
            // start a transaction
            await this._uSQLite.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`CreateDatabaseSchema: ${err}`);
        }
        const stmts = await this.createSchemaStatement(jsonData);
        if (stmts.length > 0) {
            const schemaStmt = stmts.join('\n');
            try {
                changes = await this._uSQLite.execute(mDB, schemaStmt);
                if (changes < 0) {
                    try {
                        await this._uSQLite.rollbackTransaction(mDB, true);
                    }
                    catch (err) {
                        return Promise.reject('CreateSchema: changes < 0 ' + `${err}`);
                    }
                }
            }
            catch (err) {
                const msg = err;
                try {
                    await this._uSQLite.rollbackTransaction(mDB, true);
                    return Promise.reject(`CreateSchema: ${msg}`);
                }
                catch (err) {
                    return Promise.reject('CreateSchema: changes < 0 ' + `${err}: ${msg}`);
                }
            }
        }
        try {
            await this._uSQLite.commitTransaction(mDB, true);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateSchema: commit ' + `${err}`);
        }
    }
    /**
     * CreateSchemaStatement
     * @param jsonData
     */
    async createSchemaStatement(jsonData) {
        const statements = [];
        // Prepare the statement to execute
        try {
            for (const jTable of jsonData.tables) {
                if (jTable.schema != null && jTable.schema.length >= 1) {
                    // create table
                    statements.push('CREATE TABLE IF NOT EXISTS ' + `${jTable.name} (`);
                    for (let j = 0; j < jTable.schema.length; j++) {
                        if (j === jTable.schema.length - 1) {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value}`);
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value}`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value}`);
                            }
                        }
                        else {
                            if (jTable.schema[j].column) {
                                statements.push(`${jTable.schema[j].column} ${jTable.schema[j].value},`);
                            }
                            else if (jTable.schema[j].foreignkey) {
                                statements.push(`FOREIGN KEY (${jTable.schema[j].foreignkey}) ${jTable.schema[j].value},`);
                            }
                            else if (jTable.schema[j].constraint) {
                                statements.push(`CONSTRAINT ${jTable.schema[j].constraint} ${jTable.schema[j].value},`);
                            }
                        }
                    }
                    statements.push(');');
                    // create trigger last_modified associated with the table
                    let trig = 'CREATE TRIGGER IF NOT EXISTS ';
                    trig += `${jTable.name}`;
                    trig += `_trigger_last_modified `;
                    trig += `AFTER UPDATE ON ${jTable.name} `;
                    trig += 'FOR EACH ROW WHEN NEW.last_modified <= ';
                    trig += 'OLD.last_modified BEGIN UPDATE ';
                    trig += `${jTable.name} `;
                    trig += `SET last_modified = `;
                    trig += "(strftime('%s','now')) WHERE id=OLD.id; END;";
                    statements.push(trig);
                }
                if (jTable.indexes != null && jTable.indexes.length >= 1) {
                    for (const jIndex of jTable.indexes) {
                        const tableName = jTable.name;
                        let stmt = `CREATE ${Object.keys(jIndex).includes('mode') ? jIndex.mode + ' ' : ''} INDEX IF NOT EXISTS `;
                        stmt += `${jIndex.name} ON ${tableName} (${jIndex.value});`;
                        statements.push(stmt);
                    }
                }
                if (jTable.triggers != null && jTable.triggers.length >= 1) {
                    for (const jTrg of jTable.triggers) {
                        const tableName = jTable.name;
                        if (jTrg.timeevent.toUpperCase().endsWith(' ON')) {
                            jTrg.timeevent = jTrg.timeevent.substring(0, jTrg.timeevent.length - 3);
                        }
                        let stmt = `CREATE TRIGGER IF NOT EXISTS `;
                        stmt += `${jTrg.name} ${jTrg.timeevent} ON ${tableName} `;
                        if (jTrg.condition)
                            stmt += `${jTrg.condition} `;
                        stmt += `${jTrg.logic};`;
                        statements.push(stmt);
                    }
                }
            }
            return Promise.resolve(statements);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * CreateDataTable
     * @param mDB
     * @param table
     * @param mode
     */
    async createDataTable(mDB, table, mode) {
        let lastId = -1;
        try {
            // Check if the table exists
            const tableExists = await this.isTableExists(mDB, true, table.name);
            if (!tableExists) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} does not exist`);
            }
            // Get the column names and types
            const tableNamesTypes = await this.getTableColumnNamesTypes(mDB, table.name);
            const tableColumnTypes = tableNamesTypes.types;
            const tableColumnNames = tableNamesTypes.names;
            if (tableColumnTypes.length === 0) {
                return Promise.reject('CreateDataTable: Table ' + `${table.name} info does not exist`);
            }
            // Loop on Table Values
            for (let j = 0; j < table.values.length; j++) {
                // Check the row number of columns
                if (table.values[j].length != tableColumnTypes.length) {
                    return Promise.reject(`CreateDataTable: Table ${table.name} ` +
                        `values row ${j} not correct length`);
                }
                // Check the column's type before proceeding
                // remove type checking for allowing RDBMS Types
                /*    const isColumnTypes: boolean = await this.checkColumnTypes(
                  tableColumnTypes,
                  table.values[j],
                );
                if (!isColumnTypes) {
                  return Promise.reject(
                    new Error(
                      `CreateDataTable: Table ${table.name} ` +
                        `values row ${j} not correct types`,
                    ),
                  );
                }
                */
                const retisIdExists = await this.isIdExists(mDB, table.name, tableColumnNames[0], table.values[j][0]);
                let stmt;
                if (mode === 'full' || (mode === 'partial' && !retisIdExists)) {
                    // Insert
                    const nameString = tableColumnNames.join();
                    const questionMarkString = await this.createQuestionMarkString(tableColumnNames.length);
                    stmt = `INSERT INTO ${table.name} (${nameString}) VALUES (`;
                    stmt += `${questionMarkString});`;
                }
                else {
                    // Update
                    const setString = await this.setNameForUpdate(tableColumnNames);
                    if (setString.length === 0) {
                        return Promise.reject(`CreateDataTable: Table ${table.name} ` +
                            `values row ${j} not set to String`);
                    }
                    stmt = `UPDATE ${table.name} SET ${setString} WHERE `;
                    if (typeof table.values[j][0] == 'string') {
                        stmt += `${tableColumnNames[0]} = '${table.values[j][0]}';`;
                    }
                    else {
                        stmt += `${tableColumnNames[0]} = ${table.values[j][0]};`;
                    }
                }
                lastId = await this._uSQLite.prepareRun(mDB, stmt, table.values[j]);
                if (lastId < 0) {
                    return Promise.reject('CreateDataTable: lastId < 0');
                }
            }
            return Promise.resolve(lastId);
        }
        catch (err) {
            return Promise.reject(`CreateDataTable: ${err}`);
        }
    }
    /**
     * GetTableColumnNamesTypes
     * @param mDB
     * @param tableName
     */
    async getTableColumnNamesTypes(mDB, tableName) {
        let resQuery = [];
        const retNames = [];
        const retTypes = [];
        const query = `PRAGMA table_info('${tableName}');`;
        try {
            resQuery = await this._uSQLite.queryAll(mDB, query, []);
            if (resQuery.length > 0) {
                for (const query of resQuery) {
                    retNames.push(query.name);
                    retTypes.push(query.type);
                }
            }
            return Promise.resolve({ names: retNames, types: retTypes });
        }
        catch (err) {
            return Promise.reject('GetTableColumnNamesTypes: ' + `${err}`);
        }
    }
    /**
     * CheckColumnTypes
     * @param tableTypes
     * @param rowValues
     */
    /*
    private async checkColumnTypes(
      tableTypes: any[],
      rowValues: any[],
    ): Promise<boolean> {
      const isType = true;
      for (let i = 0; i < rowValues.length; i++) {
        if (rowValues[i].toString().toUpperCase() != 'NULL') {
          try {
            await this.isType(tableTypes[i], rowValues[i]);
          } catch (err) {
            return Promise.reject(new Error('checkColumnTypes: Type not found'));
          }
        }
      }
      return Promise.resolve(isType);
    }
  */
    /**
     * IsType
     * @param type
     * @param value
     */
    /*
    private async isType(type: string, value: any): Promise<void> {
      let ret = false;
      if (type === 'NULL' && typeof value === 'object') ret = true;
      if (type === 'TEXT' && typeof value === 'string') ret = true;
      if (type === 'INTEGER' && typeof value === 'number') ret = true;
      if (type === 'REAL' && typeof value === 'number') ret = true;
      if (type === 'BLOB' && typeof value === 'string') ret = true;
      if (ret) {
        return Promise.resolve();
      } else {
        return Promise.reject(new Error('IsType: not a SQL Type'));
      }
    }
  */
    /**
     * IsIdExists
     * @param db
     * @param dbName
     * @param firstColumnName
     * @param key
     */
    async isIdExists(db, dbName, firstColumnName, key) {
        let ret = false;
        let query = `SELECT ${firstColumnName} FROM ` +
            `${dbName} WHERE ${firstColumnName} = `;
        if (typeof key === 'number')
            query += `${key};`;
        if (typeof key === 'string')
            query += `'${key}';`;
        try {
            const resQuery = await this._uSQLite.queryAll(db, query, []);
            if (resQuery.length === 1)
                ret = true;
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(`IsIdExists: ${err}`);
        }
    }
    /**
     * CreateQuestionMarkString
     * @param length
     */
    createQuestionMarkString(length) {
        return new Promise((resolve, reject) => {
            let retString = '';
            for (let i = 0; i < length; i++) {
                retString += '?,';
            }
            if (retString.length > 1) {
                retString = retString.slice(0, -1);
                resolve(retString);
            }
            else {
                reject('CreateQuestionMarkString: length = 0');
            }
        });
    }
    /**
     * SetNameForUpdate
     * @param names
     */
    async setNameForUpdate(names) {
        let retString = '';
        for (const name of names) {
            retString += `${name} = ? ,`;
        }
        if (retString.length > 1) {
            retString = retString.slice(0, -1);
            return Promise.resolve(retString);
        }
        else {
            return Promise.reject('SetNameForUpdate: length = 0');
        }
    }
    /**
     * IsJsonSQLite
     * @param obj
     */
    isJsonSQLite(obj) {
        const keyFirstLevel = [
            'database',
            'version',
            'encrypted',
            'mode',
            'tables',
            'views',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyFirstLevel.indexOf(key) === -1)
                return false;
            if (key === 'database' && typeof obj[key] != 'string')
                return false;
            if (key === 'version' && typeof obj[key] != 'number')
                return false;
            if (key === 'encrypted' && typeof obj[key] != 'boolean')
                return false;
            if (key === 'mode' && typeof obj[key] != 'string')
                return false;
            if (key === 'tables' && typeof obj[key] != 'object')
                return false;
            if (key === 'tables') {
                for (const oKey of obj[key]) {
                    const retTable = this.isTable(oKey);
                    if (!retTable)
                        return false;
                }
            }
            if (key === 'views' && typeof obj[key] != 'object')
                return false;
            if (key === 'views') {
                for (const oKey of obj[key]) {
                    const retView = this.isView(oKey);
                    if (!retView)
                        return false;
                }
            }
        }
        return true;
    }
    /**
     * IsTable
     * @param obj
     */
    isTable(obj) {
        const keyTableLevel = [
            'name',
            'schema',
            'indexes',
            'triggers',
            'values',
        ];
        let nbColumn = 0;
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTableLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'schema' && typeof obj[key] != 'object')
                return false;
            if (key === 'indexes' && typeof obj[key] != 'object')
                return false;
            if (key === 'triggers' && typeof obj[key] != 'object')
                return false;
            if (key === 'values' && typeof obj[key] != 'object')
                return false;
            if (key === 'schema') {
                obj['schema'].forEach((element) => {
                    if (element.column) {
                        nbColumn++;
                    }
                });
                for (let i = 0; i < nbColumn; i++) {
                    const retSchema = this.isSchema(obj[key][i]);
                    if (!retSchema)
                        return false;
                }
            }
            if (key === 'indexes') {
                for (const oKey of obj[key]) {
                    const retIndexes = this.isIndexes(oKey);
                    if (!retIndexes)
                        return false;
                }
            }
            if (key === 'triggers') {
                for (const oKey of obj[key]) {
                    const retTriggers = this.isTriggers(oKey);
                    if (!retTriggers)
                        return false;
                }
            }
            if (key === 'values') {
                if (nbColumn > 0) {
                    for (const oKey of obj[key]) {
                        if (typeof oKey != 'object' || oKey.length != nbColumn)
                            return false;
                    }
                }
            }
        }
        return true;
    }
    /**
     * IsSchema
     * @param obj
     */
    isSchema(obj) {
        const keySchemaLevel = [
            'column',
            'value',
            'foreignkey',
            'constraint',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keySchemaLevel.indexOf(key) === -1)
                return false;
            if (key === 'column' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'foreignkey' && typeof obj[key] != 'string')
                return false;
            if (key === 'constraint' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * isIndexes
     * @param obj
     */
    isIndexes(obj) {
        const keyIndexesLevel = ['name', 'value', 'mode'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyIndexesLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
            if (key === 'mode' &&
                (typeof obj[key] != 'string' || obj[key] != 'UNIQUE'))
                return false;
        }
        return true;
    }
    /**
     * isTriggers
     * @param obj
     */
    isTriggers(obj) {
        const keyTriggersLevel = [
            'name',
            'timeevent',
            'condition',
            'logic',
        ];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyTriggersLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'timeevent' && typeof obj[key] != 'string')
                return false;
            if (key === 'condition' && typeof obj[key] != 'string')
                return false;
            if (key === 'logic' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * IsViews
     * @param obj
     */
    isView(obj) {
        const keyViewLevel = ['name', 'value'];
        if (obj == null ||
            (Object.keys(obj).length === 0 && obj.constructor === Object))
            return false;
        for (const key of Object.keys(obj)) {
            if (keyViewLevel.indexOf(key) === -1)
                return false;
            if (key === 'name' && typeof obj[key] != 'string')
                return false;
            if (key === 'value' && typeof obj[key] != 'string')
                return false;
        }
        return true;
    }
    /**
     * checkSchemaValidity
     * @param schema
     */
    async checkSchemaValidity(schema) {
        for (let i = 0; i < schema.length; i++) {
            const sch = {};
            const keys = Object.keys(schema[i]);
            if (keys.includes('column')) {
                sch.column = schema[i].column;
            }
            if (keys.includes('value')) {
                sch.value = schema[i].value;
            }
            if (keys.includes('foreignkey')) {
                sch.foreignkey = schema[i].foreignkey;
            }
            if (keys.includes('constraint')) {
                sch.constraint = schema[i].constraint;
            }
            const isValid = this.isSchema(sch);
            if (!isValid) {
                return Promise.reject(`CheckSchemaValidity: schema[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkIndexesSchemaValidity
     * @param indexes
     */
    async checkIndexesValidity(indexes) {
        for (let i = 0; i < indexes.length; i++) {
            const index = {};
            const keys = Object.keys(indexes[i]);
            if (keys.includes('value')) {
                index.value = indexes[i].value;
            }
            if (keys.includes('name')) {
                index.name = indexes[i].name;
            }
            if (keys.includes('mode')) {
                index.mode = indexes[i].mode;
            }
            const isValid = this.isIndexes(index);
            if (!isValid) {
                return Promise.reject(`CheckIndexesValidity: indexes[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkTriggersValidity
     * @param triggers
     */
    async checkTriggersValidity(triggers) {
        for (let i = 0; i < triggers.length; i++) {
            const trigger = {};
            const keys = Object.keys(triggers[i]);
            if (keys.includes('logic')) {
                trigger.logic = triggers[i].logic;
            }
            if (keys.includes('name')) {
                trigger.name = triggers[i].name;
            }
            if (keys.includes('timeevent')) {
                trigger.timeevent = triggers[i].timeevent;
            }
            if (keys.includes('condition')) {
                trigger.condition = triggers[i].condition;
            }
            const isValid = this.isTriggers(trigger);
            if (!isValid) {
                return Promise.reject(`CheckTriggersValidity: triggers[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * checkViewsValidity
     * @param views
     */
    async checkViewsValidity(views) {
        for (let i = 0; i < views.length; i++) {
            const view = {};
            const keys = Object.keys(views[i]);
            if (keys.includes('value')) {
                view.value = views[i].value;
            }
            if (keys.includes('name')) {
                view.name = views[i].name;
            }
            const isValid = this.isView(view);
            if (!isValid) {
                return Promise.reject(`CheckViewsValidity: views[${i}] not valid`);
            }
        }
        return Promise.resolve();
    }
    /**
     * CreateView
     * @param mDB
     * @param table
     */
    async createView(mDB, view) {
        const stmt = `CREATE VIEW IF NOT EXISTS ${view.name} AS ${view.value};`;
        try {
            const changes = await this._uSQLite.execute(mDB, stmt);
            if (changes < 0) {
                return Promise.reject(`CreateView: ${view.name} failed`);
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CreateView: ${err}`);
        }
    }
}
utilsJson.UtilsJson = UtilsJson;

Object.defineProperty(exportToJson, "__esModule", { value: true });
exportToJson.ExportToJson = void 0;
const utilsSQLite_1$4 = utilsSQLite;
const utilsJson_1$4 = utilsJson;
class ExportToJson {
    constructor() {
        this._uSQLite = new utilsSQLite_1$4.UtilsSQLite();
        this._uJson = new utilsJson_1$4.UtilsJson();
    }
    /**
     * CreateExportObject
     * @param mDB
     * @param sqlObj
     */
    async createExportObject(mDB, sqlObj) {
        const retObj = {};
        let tables = [];
        let views = [];
        let errmsg = '';
        try {
            // get View's name
            views = await this.getViewsName(mDB);
            // get Table's name
            const resTables = await this.getTablesNameSQL(mDB);
            if (resTables.length === 0) {
                return Promise.reject("createExportObject: table's names failed");
            }
            else {
                switch (sqlObj.mode) {
                    case 'partial': {
                        tables = await this.getTablesPartial(mDB, resTables);
                        break;
                    }
                    case 'full': {
                        tables = await this.getTablesFull(mDB, resTables);
                        break;
                    }
                    default: {
                        errmsg =
                            'createExportObject: expMode ' + sqlObj.mode + ' not defined';
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
                if (tables.length > 0) {
                    retObj.database = sqlObj.database;
                    retObj.version = sqlObj.version;
                    retObj.encrypted = sqlObj.encrypted;
                    retObj.mode = sqlObj.mode;
                    retObj.tables = tables;
                    if (views.length > 0) {
                        retObj.views = views;
                    }
                }
                return Promise.resolve(retObj);
            }
        }
        catch (err) {
            return Promise.reject('createExportObject: ' + err);
        }
    }
    /**
     * GetTablesNameSQL
     * @param mDb
     */
    async getTablesNameSQL(mDb) {
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this._uSQLite.queryAll(mDb, sql, []);
            return Promise.resolve(retQuery);
        }
        catch (err) {
            return Promise.reject(`getTablesNameSQL: ${err}`);
        }
    }
    /**
     * GetViewsNameSQL
     * @param mDb
     */
    async getViewsName(mDb) {
        const views = [];
        let sql = 'SELECT name,sql FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%';";
        let retQuery = [];
        try {
            retQuery = await this._uSQLite.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                const view = {};
                view.name = query.name;
                view.value = query.sql.substring(query.sql.indexOf('AS ') + 3);
                views.push(view);
            }
            return Promise.resolve(views);
        }
        catch (err) {
            return Promise.reject(`getViewsName: ${err}`);
        }
    }
    /**
     * GetSyncDate
     * @param mDb
     */
    async getSyncDate(mDb) {
        return new Promise((resolve, reject) => {
            let retDate = -1;
            // get the last sync date
            const stmt = `SELECT sync_date FROM sync_table;`;
            mDb.get(stmt, [], (err, row) => {
                // process the row here
                if (err) {
                    reject(`GetSyncDate: ${err.message}`);
                }
                else {
                    if (row != null) {
                        const key = Object.keys(row)[0];
                        retDate = row[key];
                        resolve(retDate);
                    }
                    else {
                        reject(`GetSyncDate: no syncDate`);
                    }
                }
            });
        });
    }
    /**
     * GetTablesFull
     * @param mDb
     * @param resTables
     */
    async getTablesFull(mDb, resTables) {
        const tables = [];
        let errmsg = '';
        try {
            // Loop through the tables
            for (const rTable of resTables) {
                let tableName;
                let sqlStmt;
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                const table = {};
                // create Table's Schema
                const schema = await this.getSchema(sqlStmt);
                if (schema.length === 0) {
                    errmsg = 'GetTablesFull: no Schema returned';
                    break;
                }
                // check schema validity
                await this._uJson.checkSchemaValidity(schema);
                // create Table's indexes if any
                const indexes = await this.getIndexes(mDb, tableName);
                if (indexes.length > 0) {
                    // check indexes validity
                    await this._uJson.checkIndexesValidity(indexes);
                }
                // create Table's triggers if any
                const triggers = await this.getTriggers(mDb, tableName);
                if (triggers.length > 0) {
                    // check triggers validity
                    await this._uJson.checkTriggersValidity(triggers);
                }
                // create Table's Data
                const query = `SELECT * FROM ${tableName};`;
                const values = await this.getValues(mDb, query, tableName);
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                else {
                    errmsg = `GetTablesFull: must contain schema`;
                    break;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesFull: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesFull: ${err}`);
        }
    }
    /**
     * GetSchema
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getSchema(sqlStmt /*,tableName: string,*/) {
        const schema = [];
        // take the substring between parenthesis
        const openPar = sqlStmt.indexOf('(');
        const closePar = sqlStmt.lastIndexOf(')');
        let sstr = sqlStmt.substring(openPar + 1, closePar);
        // check if there is other parenthesis and replace the ',' by 'ยง'
        try {
            sstr = await this.modEmbeddedParentheses(sstr);
            const sch = sstr.split(',');
            // for each element of the array split the
            // first word as key
            for (const sc of sch) {
                const row = [];
                const scht = sc.trim();
                row[0] = scht.substring(0, scht.indexOf(' '));
                row[1] = scht.substring(scht.indexOf(' ') + 1);
                const jsonRow = {};
                if (row[0].toUpperCase() === 'FOREIGN') {
                    const oPar = sc.indexOf('(');
                    const cPar = sc.indexOf(')');
                    row[0] = sc.substring(oPar + 1, cPar);
                    row[1] = sc.substring(cPar + 2);
                    jsonRow['foreignkey'] = row[0];
                }
                else if (row[0].toUpperCase() === 'CONSTRAINT') {
                    const tRow = [];
                    const row1t = row[1].trim();
                    tRow[0] = row1t.substring(0, row1t.indexOf(' '));
                    tRow[1] = row1t.substring(row1t.indexOf(' ') + 1);
                    row[0] = tRow[0];
                    jsonRow['constraint'] = row[0];
                    row[1] = tRow[1];
                }
                else {
                    jsonRow['column'] = row[0];
                }
                jsonRow['value'] = row[1].replace(/ยง/g, ',');
                schema.push(jsonRow);
            }
            return Promise.resolve(schema);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    /**
     * GetIndexes
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getIndexes(mDb, tableName) {
        const indexes = [];
        let errmsg = '';
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'index' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOTNULL;`;
            const retIndexes = await this._uSQLite.queryAll(mDb, stmt, []);
            if (retIndexes.length > 0) {
                for (const rIndex of retIndexes) {
                    const keys = Object.keys(rIndex);
                    if (keys.length === 3) {
                        if (rIndex['tbl_name'] === tableName) {
                            const sql = rIndex['sql'];
                            const mode = sql.includes('UNIQUE') ? 'UNIQUE' : '';
                            const oPar = sql.lastIndexOf('(');
                            const cPar = sql.lastIndexOf(')');
                            const index = {};
                            index.name = rIndex['name'];
                            index.value = sql.slice(oPar + 1, cPar);
                            if (mode.length > 0)
                                index.mode = mode;
                            indexes.push(index);
                        }
                        else {
                            errmsg = `GetIndexes: Table ${tableName} doesn't match`;
                            break;
                        }
                    }
                    else {
                        errmsg = `GetIndexes: Table ${tableName} creating indexes`;
                        break;
                    }
                }
                if (errmsg.length > 0) {
                    return Promise.reject(errmsg);
                }
            }
            return Promise.resolve(indexes);
        }
        catch (err) {
            return Promise.reject(`GetIndexes: ${err}`);
        }
    }
    /**
     * GetTriggers
     * @param mDb
     * @param sqlStmt
     * @param tableName
     */
    async getTriggers(mDb, tableName) {
        const triggers = [];
        try {
            let stmt = 'SELECT name,tbl_name,sql FROM sqlite_master WHERE ';
            stmt += `type = 'trigger' AND tbl_name = '${tableName}' `;
            stmt += `AND sql NOT NULL;`;
            const retTriggers = await this._uSQLite.queryAll(mDb, stmt, []);
            if (retTriggers.length > 0) {
                for (const rTrg of retTriggers) {
                    const keys = Object.keys(rTrg);
                    if (keys.length === 3) {
                        if (rTrg['tbl_name'] === tableName) {
                            const sql = rTrg['sql'];
                            const name = rTrg['name'];
                            let sqlArr = sql.split(name);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split name does not return 2 values`);
                            }
                            if (!sqlArr[1].includes(tableName)) {
                                return Promise.reject(`GetTriggers: sql split does not contains ${tableName}`);
                            }
                            const timeEvent = sqlArr[1].split(tableName, 1)[0].trim();
                            sqlArr = sqlArr[1].split(timeEvent + ' ' + tableName);
                            if (sqlArr.length != 2) {
                                return Promise.reject(`GetTriggers: sql split tableName does not return 2 values`);
                            }
                            let condition = '';
                            let logic = '';
                            if (sqlArr[1].trim().substring(0, 5).toUpperCase() !== 'BEGIN') {
                                sqlArr = sqlArr[1].trim().split('BEGIN');
                                if (sqlArr.length != 2) {
                                    return Promise.reject(`GetTriggers: sql split BEGIN does not return 2 values`);
                                }
                                condition = sqlArr[0].trim();
                                logic = 'BEGIN' + sqlArr[1];
                            }
                            else {
                                logic = sqlArr[1].trim();
                            }
                            const trigger = {};
                            trigger.name = name;
                            trigger.logic = logic;
                            if (condition.length > 0)
                                trigger.condition = condition;
                            trigger.timeevent = timeEvent;
                            triggers.push(trigger);
                        }
                        else {
                            return Promise.reject(`GetTriggers: Table ${tableName} doesn't match`);
                        }
                    }
                    else {
                        return Promise.reject(`GetTriggers: Table ${tableName} creating indexes`);
                    }
                }
            }
            return Promise.resolve(triggers);
        }
        catch (err) {
            return Promise.reject(`GetTriggers: ${err}`);
        }
    }
    /**
     * GetValues
     * @param mDb
     * @param query
     * @param tableName
     */
    async getValues(mDb, query, tableName) {
        const values = [];
        try {
            // get table column names and types
            const tableNamesTypes = await this._uJson.getTableColumnNamesTypes(mDb, tableName);
            let rowNames = [];
            if (Object.keys(tableNamesTypes).includes('names')) {
                rowNames = tableNamesTypes.names;
            }
            else {
                return Promise.reject(`GetValues: Table ${tableName} no names`);
            }
            const retValues = await this._uSQLite.queryAll(mDb, query, []);
            for (const rValue of retValues) {
                const row = [];
                for (const rName of rowNames) {
                    if (Object.keys(rValue).includes(rName)) {
                        row.push(rValue[rName]);
                    }
                    else {
                        row.push('NULL');
                    }
                }
                values.push(row);
            }
            return Promise.resolve(values);
        }
        catch (err) {
            return Promise.reject(`GetValues: ${err}`);
        }
    }
    /**
     * GetTablesPartial
     * @param mDb
     * @param resTables
     */
    async getTablesPartial(mDb, resTables) {
        const tables = [];
        let modTables = {};
        let syncDate = 0;
        let modTablesKeys = [];
        let errmsg = '';
        try {
            // Get the syncDate and the Modified Tables
            const partialModeData = await this.getPartialModeData(mDb, resTables);
            if (Object.keys(partialModeData).includes('syncDate')) {
                syncDate = partialModeData.syncDate;
            }
            if (Object.keys(partialModeData).includes('modTables')) {
                modTables = partialModeData.modTables;
                modTablesKeys = Object.keys(modTables);
            }
            // Loop trough tables
            for (const rTable of resTables) {
                let tableName = '';
                let sqlStmt = '';
                if (rTable.name) {
                    tableName = rTable.name;
                }
                else {
                    errmsg = 'GetTablesFull: no name';
                    break;
                }
                if (rTable.sql) {
                    sqlStmt = rTable.sql;
                }
                else {
                    errmsg = 'GetTablesFull: no sql';
                    break;
                }
                if (modTablesKeys.length == 0 ||
                    modTablesKeys.indexOf(tableName) === -1 ||
                    modTables[tableName] == 'No') {
                    continue;
                }
                const table = {};
                let schema = [];
                let indexes = [];
                let triggers = [];
                table.name = rTable;
                if (modTables[table.name] === 'Create') {
                    // create Table's Schema
                    schema = await this.getSchema(sqlStmt);
                    if (schema.length > 0) {
                        // check schema validity
                        await this._uJson.checkSchemaValidity(schema);
                    }
                    // create Table's indexes if any
                    indexes = await this.getIndexes(mDb, tableName);
                    if (indexes.length > 0) {
                        // check indexes validity
                        await this._uJson.checkIndexesValidity(indexes);
                    }
                    // create Table's triggers if any
                    triggers = await this.getTriggers(mDb, tableName);
                    if (triggers.length > 0) {
                        // check triggers validity
                        await this._uJson.checkTriggersValidity(triggers);
                    }
                }
                // create Table's Data
                let query = '';
                if (modTables[tableName] === 'Create') {
                    query = `SELECT * FROM ${tableName};`;
                }
                else {
                    query =
                        `SELECT * FROM ${tableName} ` +
                            `WHERE last_modified > ${syncDate};`;
                }
                const values = await this.getValues(mDb, query, tableName);
                // check the table object validity
                table.name = tableName;
                if (schema.length > 0) {
                    table.schema = schema;
                }
                if (indexes.length > 0) {
                    table.indexes = indexes;
                }
                if (triggers.length > 0) {
                    table.triggers = triggers;
                }
                if (values.length > 0) {
                    table.values = values;
                }
                if (Object.keys(table).length <= 1) {
                    errmsg = `GetTablesPartial: table ${tableName} is not a jsonTable`;
                    break;
                }
                tables.push(table);
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(tables);
        }
        catch (err) {
            return Promise.reject(`GetTablesPartial: ${err}`);
        }
    }
    /**
     * GetPartialModeData
     * @param mDb
     * @param resTables
     */
    async getPartialModeData(mDb, resTables) {
        const retData = {};
        try {
            // get the synchronization date
            const syncDate = await this.getSyncDate(mDb);
            if (syncDate <= 0) {
                return Promise.reject(`GetPartialModeData: no syncDate`);
            }
            // get the tables which have been updated
            // since last synchronization
            const modTables = await this.getTablesModified(mDb, resTables, syncDate);
            if (modTables.length <= 0) {
                return Promise.reject(`GetPartialModeData: no modTables`);
            }
            retData.syncDate = syncDate;
            retData.modTables = modTables;
            return Promise.resolve(retData);
        }
        catch (err) {
            return Promise.reject(`GetPartialModeData: ${err}`);
        }
    }
    async getTablesModified(db, tables, syncDate) {
        let errmsg = '';
        try {
            const retModified = {};
            for (const rTable of tables) {
                let mode;
                // get total count of the table
                let stmt = 'SELECT count(*) AS tcount  ';
                stmt += `FROM ${rTable.name};`;
                let retQuery = await this._uSQLite.queryAll(db, stmt, []);
                if (retQuery.length != 1) {
                    errmsg = 'GetTableModified: total ' + 'count not returned';
                    break;
                }
                const totalCount = retQuery[0]['tcount'];
                // get total count of modified since last sync
                stmt = 'SELECT count(*) AS mcount FROM ';
                stmt += `${rTable.name} WHERE last_modified > `;
                stmt += `${syncDate};`;
                retQuery = await this._uSQLite.queryAll(db, stmt, []);
                if (retQuery.length != 1)
                    break;
                const totalModifiedCount = retQuery[0]['mcount'];
                if (totalModifiedCount === 0) {
                    mode = 'No';
                }
                else if (totalCount === totalModifiedCount) {
                    mode = 'Create';
                }
                else {
                    mode = 'Modified';
                }
                const key = rTable.name;
                retModified[key] = mode;
            }
            if (errmsg.length > 0) {
                return Promise.reject(errmsg);
            }
            return Promise.resolve(retModified);
        }
        catch (err) {
            return Promise.reject(`GetTableModified: ${err}`);
        }
    }
    async modEmbeddedParentheses(sstr) {
        const oParArray = this.indexOfChar(sstr, '(');
        const cParArray = this.indexOfChar(sstr, ')');
        if (oParArray.length != cParArray.length) {
            return Promise.reject("ModEmbeddedParentheses: Not same number of '(' & ')'");
        }
        if (oParArray.length === 0) {
            return Promise.resolve(sstr);
        }
        let resStmt = sstr.substring(0, oParArray[0] - 1);
        for (let i = 0; i < oParArray.length; i++) {
            let str;
            if (i < oParArray.length - 1) {
                if (oParArray[i + 1] < cParArray[i]) {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i + 1]);
                    i++;
                }
                else {
                    str = sstr.substring(oParArray[i] - 1, cParArray[i]);
                }
            }
            else {
                str = sstr.substring(oParArray[i] - 1, cParArray[i]);
            }
            const newS = str.replace(/,/g, 'ยง');
            resStmt += newS;
            if (i < oParArray.length - 1) {
                resStmt += sstr.substring(cParArray[i], oParArray[i + 1] - 1);
            }
        }
        resStmt += sstr.substring(cParArray[cParArray.length - 1], sstr.length);
        return Promise.resolve(resStmt);
    }
    indexOfChar(str, char) {
        const tmpArr = [...str];
        char = char.toLowerCase();
        return tmpArr.reduce((results, elem, idx) => elem.toLowerCase() === char ? [...results, idx] : results, []);
    }
}
exportToJson.ExportToJson = ExportToJson;

var importFromJson = {};

var utilsDrop = {};

Object.defineProperty(utilsDrop, "__esModule", { value: true });
utilsDrop.UtilsDrop = void 0;
const utilsSQLite_1$3 = utilsSQLite;
class UtilsDrop {
    constructor() {
        this._uSQLite = new utilsSQLite_1$3.UtilsSQLite();
    }
    /**
     * GetTablesNames
     * @param mDb
     */
    async getTablesNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='table' AND name NOT LIKE 'sync_table' ";
        sql += "AND name NOT LIKE '_temp_%' ";
        sql += "AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this._uSQLite.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getTablesNames: ${err}`);
        }
    }
    /**
     * GetViewsNames
     * @param mDb
     */
    async getViewsNames(mDb) {
        let sql = 'SELECT name FROM sqlite_master WHERE ';
        sql += "type='view' AND name NOT LIKE 'sqlite_%' ";
        sql += 'ORDER BY rootpage DESC;';
        const retArr = [];
        try {
            const retQuery = await this._uSQLite.queryAll(mDb, sql, []);
            for (const query of retQuery) {
                retArr.push(query.name);
            }
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`getViewsNames: ${err}`);
        }
    }
    /**
     * DropElements
     * @param db
     * @param type ["table","index","trigger"]
     */
    async dropElements(db, type) {
        let msg = '';
        switch (type) {
            case 'index':
                msg = 'DropIndexes';
                break;
            case 'trigger':
                msg = 'DropTriggers';
                break;
            case 'table':
                msg = 'DropTables';
                break;
            case 'view':
                msg = 'DropViews';
                break;
            default:
                return Promise.reject(`DropElements: ${type} ` + 'not found');
        }
        // get the element's names
        let stmt = 'SELECT name FROM sqlite_master WHERE ';
        stmt += `type = '${type}' AND name NOT LIKE 'sqlite_%';`;
        try {
            const elements = await this._uSQLite.queryAll(db, stmt, []);
            if (elements.length > 0) {
                const upType = type.toUpperCase();
                const statements = [];
                for (const elem of elements) {
                    let stmt = `DROP ${upType} IF EXISTS `;
                    stmt += `${elem.name};`;
                    statements.push(stmt);
                }
                for (const stmt of statements) {
                    const lastId = await this._uSQLite.prepareRun(db, stmt, []);
                    if (lastId < 0) {
                        return Promise.reject(`${msg}: lastId < 0`);
                    }
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`${msg}: ${err}`);
        }
    }
    /**
     * DropAll
     * Drop all database's elements
     * @param db
     */
    async dropAll(db) {
        try {
            // drop tables
            await this.dropElements(db, 'table');
            // drop indexes
            await this.dropElements(db, 'index');
            // drop triggers
            await this.dropElements(db, 'trigger');
            // drop views
            await this.dropElements(db, 'view');
            // vacuum the database
            await this._uSQLite.prepareRun(db, 'VACUUM;', []);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropAll: ${err}`);
        }
    }
    /**
     * DropTempTables
     * @param db
     * @param alterTables
     */
    async dropTempTables(db, alterTables) {
        const tempTables = Object.keys(alterTables);
        const statements = [];
        for (const tTable of tempTables) {
            let stmt = 'DROP TABLE IF EXISTS ';
            stmt += `_temp_${tTable};`;
            statements.push(stmt);
        }
        try {
            const changes = await this._uSQLite.execute(db, statements.join('\n'));
            if (changes < 0) {
                return Promise.reject('DropTempTables: changes < 0');
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`DropTempTables: ${err}`);
        }
    }
}
utilsDrop.UtilsDrop = UtilsDrop;

Object.defineProperty(importFromJson, "__esModule", { value: true });
importFromJson.ImportFromJson = void 0;
const utilsDrop_1$1 = utilsDrop;
const utilsSQLite_1$2 = utilsSQLite;
const utilsJson_1$3 = utilsJson;
class ImportFromJson {
    constructor() {
        this._uJson = new utilsJson_1$3.UtilsJson();
        this._uSQLite = new utilsSQLite_1$2.UtilsSQLite();
        this._uDrop = new utilsDrop_1$1.UtilsDrop();
    }
    /**
     * CreateDatabaseSchema
     * @param mDB
     * @param jsonData
     */
    async createDatabaseSchema(mDB, jsonData) {
        let changes = -1;
        const version = jsonData.version;
        try {
            // set Foreign Keys On
            await this._uSQLite.setForeignKeyConstraintsEnabled(mDB, true);
            // set User Version PRAGMA
            await this._uSQLite.setVersion(mDB, version);
            // DROP ALL when mode="full"
            if (jsonData.mode === 'full') {
                await this._uDrop.dropAll(mDB);
            }
            // create database schema
            changes = await this._uJson.createSchema(mDB, jsonData);
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject('CreateDatabaseSchema: ' + `${err}`);
        }
    }
    async createTablesData(mDB, jsonData) {
        let changes = 0;
        let isValue = false;
        let lastId = -1;
        let msg = '';
        let initChanges = -1;
        try {
            initChanges = await this._uSQLite.dbChanges(mDB);
            // start a transaction
            await this._uSQLite.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createTablesData: ${err}`);
        }
        for (const jTable of jsonData.tables) {
            if (jTable.values != null && jTable.values.length >= 1) {
                // Create the table's data
                try {
                    lastId = await this._uJson.createDataTable(mDB, jTable, jsonData.mode);
                    if (lastId < 0)
                        break;
                    isValue = true;
                }
                catch (err) {
                    msg = err;
                    isValue = false;
                    break;
                }
            }
        }
        if (isValue) {
            try {
                await this._uSQLite.commitTransaction(mDB, true);
                changes = (await this._uSQLite.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createTablesData: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this._uSQLite.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createTablesData: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createTablesData: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no values given
                return Promise.resolve(0);
            }
        }
    }
    /**
     * CreateViews
     * @param mDB
     * @param jsonData
     */
    async createViews(mDB, jsonData) {
        let isView = false;
        let msg = '';
        let initChanges = -1;
        let changes = -1;
        try {
            initChanges = await this._uSQLite.dbChanges(mDB);
            // start a transaction
            await this._uSQLite.beginTransaction(mDB, true);
        }
        catch (err) {
            return Promise.reject(`createViews: ${err}`);
        }
        for (const jView of jsonData.views) {
            if (jView.value != null) {
                // Create the view
                try {
                    await this._uJson.createView(mDB, jView);
                    isView = true;
                }
                catch (err) {
                    msg = err;
                    isView = false;
                    break;
                }
            }
        }
        if (isView) {
            try {
                await this._uSQLite.commitTransaction(mDB, true);
                changes = (await this._uSQLite.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject('createViews: ' + `${err}`);
            }
        }
        else {
            if (msg.length > 0) {
                try {
                    await this._uSQLite.rollbackTransaction(mDB, true);
                    return Promise.reject(new Error(`createViews: ${msg}`));
                }
                catch (err) {
                    return Promise.reject('createViews: ' + `${err}: ${msg}`);
                }
            }
            else {
                // case were no views given
                return Promise.resolve(0);
            }
        }
    }
}
importFromJson.ImportFromJson = ImportFromJson;

var utilsFile = {};

Object.defineProperty(utilsFile, "__esModule", { value: true });
utilsFile.UtilsFile = void 0;
class UtilsFile {
    constructor() {
        this.pathDB = 'Databases';
        this.Path = null;
        this.NodeFs = null;
        this.JSZip = null;
        this.Os = null;
        this.AppName = '';
        this.HomeDir = '';
        this.sep = '/';
        this.Path = require$$0__default$1['default'];
        this.NodeFs = require$$1__default['default'];
        this.Os = require$$2__default['default'];
        this.JSZip = require$$3__default['default'];
        this.HomeDir = this.Os.homedir();
        const dir = __dirname;
        const idx = dir.indexOf('\\');
        if (idx != -1)
            this.sep = '\\';
        this.appPath = dir.substring(0, dir.indexOf(`electron${this.sep}`) /* + 8*/);
        const rawdata = this.NodeFs.readFileSync(this.Path.resolve(this.appPath, 'package.json'));
        this.AppName = JSON.parse(rawdata).name;
        this.osType = this.Os.type();
    }
    /**
     * IsPathExists
     * @param filePath
     */
    isPathExists(filePath) {
        let ret = false;
        try {
            if (this.NodeFs.existsSync(filePath)) {
                ret = true;
            }
        }
        catch (err) {
            console.error('Error isFileExist: ' + err);
            ret = false;
        }
        return ret;
    }
    /**
     * IsFileExists
     * @param fileName
     */
    isFileExists(fileName) {
        let ret = false;
        const filePath = this.getFilePath(fileName);
        if (filePath.length > 0) {
            ret = this.isPathExists(filePath);
        }
        return ret;
    }
    /**
     * GetFilePath
     * get the file path
     * @param fileName
     */
    getFilePath(fileName) {
        return this.Path.join(this.getDatabasesPath(), fileName);
    }
    /**
     * GetCustomerPath
     * get the customer path
     */
    getCustomerPath(custPath) {
        return this.Path.join(this.HomeDir, custPath);
    }
    /**
     * GetCustomerFilePath
     * get the customer file path
     */
    getCustomerFilePath(custPath, file) {
        return this.Path.join(custPath, file);
    }
    /**
     * GetDatabasesPath
     * get the database folder path
     */
    getDatabasesPath() {
        let retPath = '';
        const dbFolder = this.pathDB;
        retPath = this.Path.join(this.HomeDir, dbFolder, this.AppName);
        let retB = this._createFolderIfNotExists(this.Path.join(this.HomeDir, dbFolder));
        if (retB) {
            retB = this._createFolderIfNotExists(this.Path.join(this.HomeDir, dbFolder, this.AppName));
            if (!retB)
                retPath = '';
        }
        else {
            retPath = '';
        }
        return retPath;
    }
    /**
     * GetAssetsDatabasesPath
     * get the assets databases folder path
     */
    getAssetsDatabasesPath() {
        let retPath = '';
        const rawdata = this.NodeFs.readFileSync(this.Path.resolve(this.appPath, 'capacitor.config.json'));
        const webDir = JSON.parse(rawdata).webDir;
        const dir = webDir === 'www' ? 'src' : 'public';
        retPath = this.Path.resolve(this.appPath, dir, 'assets', this.pathDB.toLowerCase());
        return retPath;
    }
    /**
     * SetPathSuffix
     * @param db
     */
    setPathSuffix(db) {
        let toDb = db;
        const ext = '.db';
        const sep = this.Path.sep;
        if (db.substring(db.length - 3) === ext) {
            if (!db.includes('SQLite.db')) {
                toDb = db.slice(db.lastIndexOf(sep) + 1, -3) + 'SQLite.db';
            }
        }
        return toDb;
    }
    /**
     * GetFileList
     * get the file list for a given folder
     * @param path
     */
    async getFileList(path) {
        const filenames = this.NodeFs.readdirSync(path);
        const dbs = [];
        filenames.forEach((file) => {
            if (this.Path.extname(file) == '.db' || this.Path.extname(file) == '.zip')
                dbs.push(file);
        });
        return Promise.resolve(dbs);
    }
    /**
     * CopyFromAssetToDatabase
     * @param db
     * @param overwrite
     */
    async copyFromAssetToDatabase(db, overwrite) {
        const pAsset = this.Path.join(this.getAssetsDatabasesPath(), db);
        const toDb = this.setPathSuffix(db);
        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
        await this.copyFilePath(pAsset, pDb, overwrite);
        return Promise.resolve();
    }
    /**
     * unzipDatabase
     * @param db
     * @param overwrite
     */
    async unzipDatabase(db, overwrite) {
        const pZip = this.Path.join(this.getAssetsDatabasesPath(), db);
        // Read the Zip file
        this.NodeFs.readFile(pZip, (err, data) => {
            if (err) {
                console.log(err);
                return Promise.reject(`unzipDatabase ${JSON.stringify(err)}`);
            }
            const zip = new this.JSZip();
            zip.loadAsync(data).then((contents) => {
                Object.keys(contents.files).forEach(filename => {
                    zip
                        .file(filename)
                        .async('nodebuffer')
                        .then(async (content) => {
                        const toDb = this.setPathSuffix(filename);
                        const pDb = this.Path.join(this.getDatabasesPath(), toDb);
                        // check filePath exists
                        const isPath = this.isPathExists(pDb);
                        if (!isPath || overwrite) {
                            if (overwrite && isPath) {
                                await this.deleteFilePath(pDb);
                            }
                            this.NodeFs.writeFileSync(pDb, content);
                        }
                        return Promise.resolve();
                    });
                });
            });
        });
    }
    /**
     * CopyFileName
     * Copy file name
     * @param fileName
     * @param toFileName
     */
    async copyFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.copyFilePath(filePath, toFilePath, true);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`CopyFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('CopyFileName: cannot get the ' + 'filePath');
        }
    }
    /**
     * CopyFilePath
     * Copy file Path
     * @param filePath
     * @param toFilePath
     */
    async copyFilePath(filePath, toFilePath, overwrite) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(toFilePath);
            if (!isPath || overwrite) {
                try {
                    if (overwrite && isPath) {
                        await this.deleteFilePath(toFilePath);
                    }
                    this.NodeFs.copyFileSync(filePath, toFilePath);
                }
                catch (err) {
                    return Promise.reject(`CopyFilePath: ${err}`);
                }
            }
            return Promise.resolve();
        }
        else {
            return Promise.reject('CopyFilePath: cannot get the ' + 'filePath');
        }
    }
    async copyFile(fromPath, fromFile, toPath, toFile) {
        const fPath = this.Path.join(fromPath, fromFile);
        const tPath = this.Path.join(toPath, toFile);
        try {
            this.NodeFs.copyFileSync(fPath, tPath);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`CopyFile: ${err}`);
        }
    }
    /**
     * DeleteFileName
     * Delete a file by its name
     * @param fileName
     */
    async deleteFileName(fileName) {
        // get file path
        const filePath = this.getFilePath(fileName);
        if (filePath.length !== 0) {
            try {
                await this.deleteFilePath(filePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject('DeleteFileName: delete filePath ' + `failed ${err}`);
            }
        }
        else {
            return Promise.reject('DeleteFileName: get filePath ' + 'failed');
        }
    }
    /**
     * DeleteFilePath
     * Delete a file by its path
     * @param filePath
     */
    async deleteFilePath(filePath) {
        if (filePath.length !== 0) {
            // check if path exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                try {
                    this.NodeFs.unlinkSync(filePath);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('DeleteFilePath: ' + `${err}`);
                }
            }
            else {
                return Promise.resolve();
            }
        }
        else {
            return Promise.reject('DeleteFilePath: delete filePath' + 'failed');
        }
    }
    /**
     * RenameFileName
     * @param fileName
     * @param toFileName
     */
    async renameFileName(fileName, toFileName) {
        // get File Paths
        const filePath = this.getFilePath(fileName);
        const toFilePath = this.getFilePath(toFileName);
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            try {
                await this.renameFilePath(filePath, toFilePath);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(`RenameFileName: ${err}`);
            }
        }
        else {
            return Promise.reject('RenameFileName: filePaths do not ' + 'exist');
        }
    }
    /**
     * RenameFilePath
     * @param filePath
     * @param toFilePath
     */
    async renameFilePath(filePath, toFilePath) {
        if (filePath.length !== 0 && toFilePath.length !== 0) {
            // check filePath exists
            const isPath = this.isPathExists(filePath);
            if (isPath) {
                // delete toFilePath if exists
                try {
                    await this.deleteFilePath(toFilePath);
                    this.NodeFs.renameSync(filePath, toFilePath);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RenameFilePath: ' + `${err}`);
                }
            }
            else {
                return Promise.reject('RenameFilePath: filePath ' + 'does not exist');
            }
        }
        else {
            return Promise.reject('RenameFilePath: filePath not found');
        }
    }
    /**
     * RestoreFileName
     * @param fileName
     * @param prefix
     */
    async restoreFileName(fileName, prefix) {
        const mFileName = `${prefix}-${fileName}`;
        // check if file exists
        const isFilePre = this.isFileExists(mFileName);
        if (isFilePre) {
            const isFile = this.isFileExists(fileName);
            if (isFile) {
                try {
                    await this.deleteFileName(fileName);
                    await this.renameFileName(mFileName, fileName);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('RestoreFileName: ' + `${err}`);
                }
            }
            else {
                return Promise.reject(`RestoreFileName: ${fileName} ` + 'does not exist');
            }
        }
        else {
            return Promise.reject(`RestoreFileName: ${mFileName} ` + 'does not exist');
        }
    }
    /**
     * CreateFolderIfNotExists
     * Create directory
     * @param folder
     */
    _createFolderIfNotExists(folder) {
        let ret;
        try {
            if (!this.NodeFs.existsSync(folder)) {
                this._mkdirSyncRecursive(folder);
            }
            ret = true;
        }
        catch (e) {
            console.log('Error: in getDBPath', e);
            ret = false;
        }
        return ret;
    }
    /**
     * MkdirSyncRecursive
     * Create directories recursively
     * @param directory
     */
    _mkdirSyncRecursive(directory) {
        const path = directory.replace(/\/$/, '').split('/');
        for (let i = 1; i <= path.length; i++) {
            const segment = path.slice(0, i).join('/');
            segment.length > 0 && !this.NodeFs.existsSync(segment)
                ? this.NodeFs.mkdirSync(segment)
                : null;
        }
        return;
    }
}
utilsFile.UtilsFile = UtilsFile;

var utilsUpgrade = {};

Object.defineProperty(utilsUpgrade, "__esModule", { value: true });
utilsUpgrade.UtilsUpgrade = void 0;
const utilsJson_1$2 = utilsJson;
const utilsDrop_1 = utilsDrop;
const utilsFile_1$2 = utilsFile;
const utilsSQLite_1$1 = utilsSQLite;
class UtilsUpgrade {
    constructor() {
        this._uSQLite = new utilsSQLite_1$1.UtilsSQLite();
        this._uFile = new utilsFile_1$2.UtilsFile();
        this._uDrop = new utilsDrop_1.UtilsDrop();
        this._uJson = new utilsJson_1$2.UtilsJson();
        this._alterTables = {};
        this._commonColumns = {};
    }
    /**
     * OnUpgrade
     * @param mDB
     * @param vUpgDict
     * @param dbName
     * @param curVersion
     * @param targetVersion
     */
    async onUpgrade(mDB, vUpgDict, dbName, curVersion, targetVersion) {
        const upgrade = vUpgDict[curVersion];
        if (upgrade != null) {
            const keys = Object.keys(upgrade);
            if (!keys.includes('toVersion')) {
                return Promise.reject('onUpgrade: toVersion not given');
            }
            const toVersion = upgrade.toVersion;
            if (!keys.includes('statement')) {
                return Promise.reject('onUpgrade: statement not given');
            }
            const statement = upgrade.statement;
            let set = [];
            if (keys.includes('set')) {
                set = upgrade.set;
            }
            if (targetVersion < toVersion) {
                let msg = 'Error: version mistmatch ';
                msg += 'Upgrade Statement would upgrade to ';
                msg += `version ${toVersion} , but target version `;
                msg += `is ${targetVersion} for database ${dbName}`;
                msg += ` and version ${curVersion}`;
                return Promise.reject(`onUpgrade: ${msg}`);
            }
            try {
                // set Foreign Keys Off
                await this._uSQLite.setForeignKeyConstraintsEnabled(mDB, false);
                await this._uFile.copyFileName(dbName, `backup-${dbName}`);
                const initChanges = await this._uSQLite.dbChanges(mDB);
                // Here we assume that all table schemas are given
                // in the upgrade statement
                if (statement.length > 0) {
                    await this.executeStatementProcess(mDB, statement);
                    // Here we assume that the Set contains only
                    // - the data for new tables
                    //   as INSERT statements
                    // - the data for new columns in existing tables
                    //   as UPDATE statements
                    if (set.length > 0) {
                        await this.executeSetProcess(mDB, set, toVersion);
                    }
                }
                // set Foreign Keys On
                await this._uSQLite.setForeignKeyConstraintsEnabled(mDB, true);
                const changes = (await this._uSQLite.dbChanges(mDB)) - initChanges;
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject(`onUpgrade: ${err}`);
            }
        }
        else {
            return Promise.reject('onUpgrade: upgrade not found');
        }
    }
    /**
     * ExecuteStatementProcess
     * @param mDB
     * @param statement
     */
    async executeStatementProcess(mDB, statement) {
        try {
            // -> backup all existing tables  "tableName" in
            //    "temp_tableName"
            await this.backupTables(mDB);
            // -> Drop all Indexes
            await this._uDrop.dropElements(mDB, 'index');
            // -> Drop all Triggers
            await this._uDrop.dropElements(mDB, 'trigger');
            // -> Create new tables from upgrade.statement
            const changes = await this._uSQLite.execute(mDB, statement);
            if (changes < 0) {
                return Promise.reject('ExecuteStatementProcess: ' + 'changes < 0');
            }
            // -> Create the list of table's common fields
            await this.findCommonColumns(mDB);
            // -> Update the new table's data from old table's data
            if (Object.keys(this._commonColumns).length > 0) {
                await this.updateNewTablesData(mDB);
            }
            // -> Drop _temp_tables
            await this._uDrop.dropTempTables(mDB, this._alterTables);
            // -> Do some cleanup
            this._alterTables = {};
            this._commonColumns = {};
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`ExecuteStatementProcess: ${err}`);
        }
    }
    /**
     * ExecuteSetProcess
     * @param mDB
     * @param set
     * @param toVersion
     */
    async executeSetProcess(mDB, set, toVersion) {
        try {
            // -> load new data
            const lastId = await this._uSQLite.executeSet(mDB, set);
            if (lastId < 0) {
                return Promise.reject('ExecuteSetProcess: lastId ' + '< 0');
            }
            // -> update database version
            await this._uSQLite.setVersion(mDB, toVersion);
            // -> update syncDate if any
            const retB = await this._uJson.isTableExists(mDB, true, 'sync_table');
            if (retB) {
                const sDate = Math.round(new Date().getTime() / 1000);
                let stmt = 'UPDATE sync_table SET ';
                stmt += `sync_date = ${sDate} WHERE id = 1;`;
                const changes = await this._uSQLite.execute(mDB, stmt);
                if (changes < 0) {
                    return Promise.reject('ExecuteSetProcess: changes ' + '< 0');
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`ExecuteSetProcess: ${err}`);
        }
    }
    /**
     * BackupTables
     * @param mDB
     */
    async backupTables(mDB) {
        const msg = 'BackupTables: ';
        try {
            const tables = await this._uDrop.getTablesNames(mDB);
            for (const table of tables) {
                try {
                    await this.backupTable(mDB, table);
                }
                catch (err) {
                    return Promise.reject(`${msg}table ${table}: ` + `${err}`);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`BackupTables: ${err}`);
        }
    }
    /**
     * BackupTable
     * @param mDB
     * @param table
     */
    async backupTable(mDB, table) {
        try {
            // start a transaction
            await this._uSQLite.beginTransaction(mDB, true);
            // get the table's column names
            const colNames = await this.getTableColumnNames(mDB, table);
            this._alterTables[`${table}`] = colNames;
            // prefix the table with _temp_
            let stmt = `ALTER TABLE ${table} RENAME `;
            stmt += `TO _temp_${table};`;
            const lastId = await this._uSQLite.prepareRun(mDB, stmt, []);
            if (lastId < 0) {
                let msg = 'BackupTable: lastId < 0';
                try {
                    await this._uSQLite.rollbackTransaction(mDB, true);
                }
                catch (err) {
                    msg += `: ${err}`;
                }
                return Promise.reject(`${msg}`);
            }
            else {
                try {
                    await this._uSQLite.commitTransaction(mDB, true);
                }
                catch (err) {
                    return Promise.reject('BackupTable: ' + `${err}`);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`BackupTable: ${err}`);
        }
    }
    /**
     * GetTableColumnNames
     * @param mDB
     * @param tableName
     */
    async getTableColumnNames(mDB, tableName) {
        let resQuery = [];
        const retNames = [];
        const query = `PRAGMA table_info('${tableName}');`;
        try {
            resQuery = await this._uSQLite.queryAll(mDB, query, []);
            if (resQuery.length > 0) {
                for (const query of resQuery) {
                    retNames.push(query.name);
                }
            }
            return Promise.resolve(retNames);
        }
        catch (err) {
            return Promise.reject('GetTableColumnNames: ' + `${err}`);
        }
    }
    /**
     * FindCommonColumns
     * @param mDB
     */
    async findCommonColumns(mDB) {
        try {
            // Get new table list
            const tables = await this._uDrop.getTablesNames(mDB);
            if (tables.length === 0) {
                return Promise.reject('FindCommonColumns: get ' + "table's names failed");
            }
            for (const table of tables) {
                // get the column's name
                const tableNames = await this.getTableColumnNames(mDB, table);
                // find the common columns
                const keys = Object.keys(this._alterTables);
                if (keys.includes(table)) {
                    this._commonColumns[table] = this.arraysIntersection(this._alterTables[table], tableNames);
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`FindCommonColumns: ${err}`);
        }
    }
    /**
     * ArraysIntersection
     * @param a1
     * @param a2
     */
    arraysIntersection(a1, a2) {
        if (a1 != null && a2 != null) {
            const first = new Set(a1);
            const second = new Set(a2);
            return [...first].filter(item => second.has(item));
        }
        else {
            return [];
        }
    }
    /**
     * UpdateNewTablesData
     * @param mDB
     */
    async updateNewTablesData(mDB) {
        try {
            // start a transaction
            await this._uSQLite.beginTransaction(mDB, true);
            const statements = [];
            const keys = Object.keys(this._commonColumns);
            keys.forEach(key => {
                const columns = this._commonColumns[key].join(',');
                let stmt = `INSERT INTO ${key} `;
                stmt += `(${columns}) `;
                stmt += `SELECT ${columns} FROM _temp_${key};`;
                statements.push(stmt);
            });
            const changes = await this._uSQLite.execute(mDB, statements.join('\n'));
            if (changes < 0) {
                let msg = 'updateNewTablesData: ' + 'changes < 0';
                try {
                    await this._uSQLite.rollbackTransaction(mDB, true);
                }
                catch (err) {
                    msg += `: ${err}`;
                }
                return Promise.reject(`${msg}`);
            }
            else {
                try {
                    await this._uSQLite.commitTransaction(mDB, true);
                    return Promise.resolve();
                }
                catch (err) {
                    return Promise.reject('updateNewTablesData: ' + `${err}`);
                }
            }
        }
        catch (err) {
            return Promise.reject('updateNewTablesData: ' + `${err}`);
        }
    }
}
utilsUpgrade.UtilsUpgrade = UtilsUpgrade;

Object.defineProperty(Database$1, "__esModule", { value: true });
Database$1.Database = void 0;
const exportToJson_1 = exportToJson;
const importFromJson_1 = importFromJson;
const utilsJson_1$1 = utilsJson;
//import { UtilsEncryption } from './utilsEncryption';
const utilsFile_1$1 = utilsFile;
const utilsSQLite_1 = utilsSQLite;
const utilsUpgrade_1 = utilsUpgrade;
class Database {
    constructor(dbName, 
    //    encrypted: boolean,
    //    mode: string,
    version, upgDict) {
        this._uFile = new utilsFile_1$1.UtilsFile();
        this._uSQLite = new utilsSQLite_1.UtilsSQLite();
        this._uJson = new utilsJson_1$1.UtilsJson();
        //  private _uGlobal: GlobalSQLite = new GlobalSQLite();
        //  private _uEncrypt: UtilsEncryption = new UtilsEncryption();
        this._uUpg = new utilsUpgrade_1.UtilsUpgrade();
        this._iFJson = new importFromJson_1.ImportFromJson();
        this._eTJson = new exportToJson_1.ExportToJson();
        this._vUpgDict = {};
        this._dbName = dbName;
        //    this._encrypted = encrypted;
        //    this._mode = mode;
        this._version = version;
        this._vUpgDict = upgDict;
        this._pathDB = this._uFile.getFilePath(dbName);
        this._isDBOpen = false;
        if (this._pathDB.length === 0)
            throw new Error('Could not generate a path to ' + dbName);
    }
    /**
     * IsDBOpen
     * return the database status
     * @param options: capSQLiteOptions
     * @returns boolean
     * @since 0.0.1
     */
    isDBOpen() {
        return this._isDBOpen;
    }
    /**
     * Open
     * open the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async open() {
        this._isDBOpen = false;
        //    let password = '';
        try {
            /*
            if (
              this._encrypted &&
              (this._mode === 'secret' || this._mode === 'encryption')
            ) {
              password = this._uGlobal.secret;
            }
            if (this._mode === 'newsecret') {
              // change the password
              const oPassword: string = this._uGlobal.secret;
              const nPassword: string = this._uGlobal.newsecret;
              await this._uSQLite.changePassword(this._pathDB, oPassword, nPassword);
              password = nPassword;
            }
      
            if (this._mode === 'encryption') {
              await this._uEncrypt.encryptDatabase(this._pathDB, password);
            }
      */
            this._mDB = await this._uSQLite.openOrCreateDatabase(this._pathDB /*,
            password,*/);
            const curVersion = await this._uSQLite.getVersion(this._mDB);
            this._isDBOpen = true;
            if (this._version > curVersion) {
                const keys = Object.keys(this._vUpgDict);
                if (keys.length > 0) {
                    try {
                        // execute the upgrade flow process
                        await this._uUpg.onUpgrade(this._mDB, this._vUpgDict, this._dbName, curVersion, this._version);
                        // delete the backup database
                        await this._uFile.deleteFileName(`backup-${this._dbName}`);
                    }
                    catch (err) {
                        // restore the database from backup
                        try {
                            await this._uFile.restoreFileName(this._dbName, 'backup');
                        }
                        catch (err) {
                            return Promise.reject(`Open: ${err}`);
                        }
                    }
                }
                else {
                    try {
                        await this._uSQLite.setVersion(this._mDB, this._version);
                    }
                    catch (err) {
                        return Promise.reject(`SetVersion: ${this._version} ${err}`);
                    }
                }
            }
            return Promise.resolve();
        }
        catch (err) {
            if (this._isDBOpen)
                this.close();
            return Promise.reject(`Open: ${err}`);
        }
    }
    /**
     * Close
     * close the @journeyapps/sqlcipher sqlite3 database
     * @returns Promise<boolean>
     */
    async close() {
        if (this._mDB != null && this._isDBOpen) {
            this._mDB.close((err) => {
                if (err) {
                    let msg = 'Close: Failed in closing: ';
                    msg += `${this._dbName}  ${err}`;
                    return Promise.reject(msg);
                }
                this._isDBOpen = false;
                return Promise.resolve();
            });
        }
        return Promise.resolve();
    }
    /**
     * GetVersion
     * get the database version
     * @returns Promise<number>
     */
    async getVersion() {
        if (this._mDB != null && this._isDBOpen) {
            try {
                const curVersion = await this._uSQLite.getVersion(this._mDB);
                return Promise.resolve(curVersion);
            }
            catch (err) {
                if (this._isDBOpen)
                    this.close();
                return Promise.reject(`getVersion: ${err}`);
            }
        }
        else {
            let msg = `getVersion: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
    }
    /**
     * DeleteDB
     * delete a database
     * @param dbName: string
     * @returns Promise<boolean>
     */
    async deleteDB(dbName) {
        // test if file exists
        const isExists = this._uFile.isFileExists(dbName);
        if (isExists && !this._isDBOpen) {
            // open the database
            try {
                await this.open();
            }
            catch (err) {
                return Promise.reject(`DeleteDB: ${err}`);
            }
        }
        // close the database
        try {
            await this.close();
        }
        catch (err) {
            return Promise.reject('DeleteDB: Close failed');
        }
        // delete the database
        if (isExists) {
            try {
                await this._uFile.deleteFileName(dbName);
            }
            catch (err) {
                let msg = `DeleteDB: deleteFile ${dbName}`;
                msg += ` failed ${err}`;
                return Promise.reject(msg);
            }
        }
        return Promise.resolve();
    }
    /**
     * IsTableExists
     * @param tableName
     * @returns
     */
    async isTableExists(tableName) {
        if (this._mDB != null && this._isDBOpen) {
            const isOpen = this._isDBOpen;
            try {
                const retB = await this._uJson.isTableExists(this._mDB, isOpen, tableName);
                return Promise.resolve(retB);
            }
            catch (err) {
                return Promise.reject(`IsTableExists: ${err}`);
            }
        }
        else {
            let msg = `isTableExists: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
    }
    /**
     * CreateSyncTable
     * create the synchronization table
     * @returns Promise<number>
     */
    async createSyncTable() {
        if (!this._isDBOpen) {
            let msg = `CreateSyncTable: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
        let changes = -1;
        const isOpen = this._isDBOpen;
        // check if the table has already being created
        try {
            const retB = await this._uJson.isTableExists(this._mDB, isOpen, 'sync_table');
            if (!retB) {
                const date = Math.round(new Date().getTime() / 1000);
                let stmts = `
                        CREATE TABLE IF NOT EXISTS sync_table (
                            id INTEGER PRIMARY KEY NOT NULL,
                            sync_date INTEGER
                            );`;
                stmts += `INSERT INTO sync_table (sync_date) VALUES (
                            "${date}");`;
                changes = await this._uSQLite.execute(this._mDB, stmts);
                if (changes < 0) {
                    return Promise.reject(`CreateSyncTable: failed changes < 0`);
                }
            }
            return Promise.resolve(changes);
        }
        catch (err) {
            return Promise.reject(`CreateSyncTable: ${err}`);
        }
    }
    /**
     * SetSyncDate
     * store the synchronization date
     * @param syncDate: string
     * @returns Promise<{result: boolean, message: string}>
     */
    async setSyncDate(syncDate) {
        if (!this._isDBOpen) {
            let msg = `SetSyncDate: Database ${this._dbName} `;
            msg += `not opened`;
            return { result: false, message: msg };
        }
        try {
            const sDate = Math.round(new Date(syncDate).getTime() / 1000);
            let stmt = `UPDATE sync_table SET sync_date = `;
            stmt += `${sDate} WHERE id = 1;`;
            const changes = await this._uSQLite.execute(this._mDB, stmt);
            if (changes < 0) {
                return { result: false, message: 'setSyncDate failed' };
            }
            else {
                return { result: true };
            }
        }
        catch (err) {
            return { result: false, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * GetSyncDate
     * store the synchronization date
     * @returns Promise<{syncDate: number, message: string}>
     */
    async getSyncDate() {
        if (!this._isDBOpen) {
            let msg = `GetSyncDate: Database ${this._dbName} `;
            msg += `not opened`;
            return { syncDate: 0, message: msg };
        }
        try {
            const syncDate = await this._eTJson.getSyncDate(this._mDB);
            if (syncDate > 0) {
                return { syncDate: syncDate };
            }
            else {
                return { syncDate: 0, message: `setSyncDate failed` };
            }
        }
        catch (err) {
            return { syncDate: 0, message: `setSyncDate failed: ${err}` };
        }
    }
    /**
     * ExecuteSQL
     * execute raw sql statements store in a string
     * @param sql: string
     * @returns Promise<number>
     */
    async executeSQL(sql, transaction) {
        if (!this._isDBOpen) {
            let msg = `ExecuteSQL: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
        try {
            if (transaction)
                await this._uSQLite.beginTransaction(this._mDB, this._isDBOpen);
            const changes = await this._uSQLite.execute(this._mDB, sql);
            if (changes < 0) {
                return Promise.reject('ExecuteSQL: changes < 0');
            }
            if (transaction)
                await this._uSQLite.commitTransaction(this._mDB, this._isDBOpen);
            return Promise.resolve(changes);
        }
        catch (err) {
            let msg = `ExecuteSQL: ${err}`;
            try {
                if (transaction)
                    await this._uSQLite.rollbackTransaction(this._mDB, this._isDBOpen);
            }
            catch (err) {
                msg += ` : ${err}`;
            }
            return Promise.reject(`ExecuteSQL: ${msg}`);
        }
    }
    /**
     * SelectSQL
     * execute a sql query with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<any[]>
     */
    async selectSQL(sql, values) {
        if (!this._isDBOpen) {
            let msg = `SelectSQL: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
        try {
            const retArr = await this._uSQLite.queryAll(this._mDB, sql, values);
            return Promise.resolve(retArr);
        }
        catch (err) {
            return Promise.reject(`SelectSQL: ${err}`);
        }
    }
    /**
     * runSQL
     * execute a raw sql statement with/without binding values
     * @param sql: string
     * @param values: string[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async runSQL(statement, values, transaction) {
        if (!this._isDBOpen) {
            let msg = `RunSQL: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
        const retRes = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this._uSQLite.dbChanges(this._mDB);
            // start a transaction
            if (transaction)
                await this._uSQLite.beginTransaction(this._mDB, this._isDBOpen);
        }
        catch (err) {
            return Promise.reject(`ExecSet: ${err}`);
        }
        try {
            const lastId = await this._uSQLite.prepareRun(this._mDB, statement, values);
            if (lastId < 0) {
                if (transaction)
                    await this._uSQLite.rollbackTransaction(this._mDB, this._isDBOpen);
                return Promise.reject(`RunSQL: return LastId < 0`);
            }
            if (transaction)
                await this._uSQLite.commitTransaction(this._mDB, this._isDBOpen);
            retRes.changes = (await this._uSQLite.dbChanges(this._mDB)) - initChanges;
            retRes.lastId = lastId;
            return Promise.resolve(retRes);
        }
        catch (err) {
            if (transaction)
                await this._uSQLite.rollbackTransaction(this._mDB, this._isDBOpen);
            return Promise.reject(`RunSQL: ${err}`);
        }
    }
    /**
     * ExecSet
     * execute a set of raw sql statements with/without binding values
     * @param set: any[]
     * @returns Promise<{changes:number, lastId:number}>
     */
    async execSet(set, transaction) {
        if (!this._isDBOpen) {
            let msg = `ExecSet: Database ${this._dbName} `;
            msg += `not opened`;
            return Promise.reject(msg);
        }
        const retRes = { changes: -1, lastId: -1 };
        let initChanges = -1;
        try {
            initChanges = await this._uSQLite.dbChanges(this._mDB);
            // start a transaction
            if (transaction)
                await this._uSQLite.beginTransaction(this._mDB, this._isDBOpen);
        }
        catch (err) {
            return Promise.reject(`ExecSet: ${err}`);
        }
        try {
            retRes.lastId = await this._uSQLite.executeSet(this._mDB, set);
            if (transaction)
                await this._uSQLite.commitTransaction(this._mDB, this._isDBOpen);
            retRes.changes = (await this._uSQLite.dbChanges(this._mDB)) - initChanges;
            return Promise.resolve(retRes);
        }
        catch (err) {
            const msg = err;
            try {
                if (transaction)
                    await this._uSQLite.rollbackTransaction(this._mDB, this._isDBOpen);
            }
            catch (err) {
                return Promise.reject(`ExecSet: ${msg}: ` + `${err}`);
            }
        }
    }
    async importJson(jsonData) {
        let changes = 0;
        if (this._isDBOpen) {
            try {
                if (jsonData.tables && jsonData.tables.length > 0) {
                    // create the database schema
                    changes = await this._iFJson.createDatabaseSchema(this._mDB, jsonData);
                    if (changes != -1) {
                        // create the tables data
                        changes += await this._iFJson.createTablesData(this._mDB, jsonData);
                    }
                }
                if (jsonData.views && jsonData.views.length > 0) {
                    // create the views
                    changes += await this._iFJson.createViews(this._mDB, jsonData);
                }
                return Promise.resolve(changes);
            }
            catch (err) {
                return Promise.reject(`ImportJson: ${err}`);
            }
        }
        else {
            return Promise.reject(`ImportJson: database is closed`);
        }
    }
    async exportJson(mode) {
        const inJson = {};
        inJson.database = this._dbName.slice(0, -9);
        inJson.version = this._version;
        inJson.encrypted = false;
        inJson.mode = mode;
        if (this._isDBOpen) {
            try {
                const retJson = await this._eTJson.createExportObject(this._mDB, inJson);
                const isValid = this._uJson.isJsonSQLite(retJson);
                if (isValid) {
                    return Promise.resolve(retJson);
                }
                else {
                    return Promise.reject(`ExportJson: retJson not valid`);
                }
            }
            catch (err) {
                return Promise.reject(`ExportJson: ${err}`);
            }
        }
        else {
            return Promise.reject(`ExportJson: database is closed`);
        }
    }
}
Database$1.Database = Database;

Object.defineProperty(src, "__esModule", { value: true });
exports.CapacitorSQLite = src.CapacitorSQLite = void 0;
const Database_1 = Database$1;
const utilsJson_1 = utilsJson;
const utilsFile_1 = utilsFile;
class CapacitorSQLite {
    constructor() {
        this._versionUpgrades = {};
        this._dbDict = {};
        this._uFile = new utilsFile_1.UtilsFile();
        this._uJson = new utilsJson_1.UtilsJson();
    }
    async initWebStore() {
        return Promise.reject('Method not implemented.');
    }
    async saveToStore(options) {
        console.log(`${JSON.stringify(options)}`);
        return Promise.reject('Method not implemented.');
    }
    async isSecretStored() {
        return Promise.reject('Method not implemented.');
    }
    async setEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        return Promise.reject('Method not implemented.');
    }
    async changeEncryptionSecret(options) {
        console.log(`${JSON.stringify(options)}`);
        return Promise.reject('Method not implemented.');
    }
    async createConnection(options) {
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const version = options.version ? options.version : 1;
        /*    const encrypted = false;
        const inMode = "no-encryption";
    
        const encrypted: boolean =
          options.encrypted && this._osType === 'Darwin'
            ? options.encrypted
            : false;
        const inMode: string =
          options.mode && this._osType === 'Darwin'
            ? options.mode
            : 'no-encryption';
        */
        let upgDict = {};
        const vUpgKeys = Object.keys(this._versionUpgrades);
        if (vUpgKeys.length !== 0 && vUpgKeys.includes(dbName)) {
            upgDict = this._versionUpgrades[dbName];
        }
        try {
            const mDb = new Database_1.Database(dbName + 'SQLite.db', 
            /*        encrypted,
            inMode,
    */
            version, upgDict);
            this._dbDict[dbName] = mDb;
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    async closeConnection(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('CloseConnection command failed: No ' +
                'available connection for ' +
                dbName);
        }
        const mDB = this._dbDict[dbName];
        if (mDB.isDBOpen()) {
            // close the database
            try {
                await mDB.close();
            }
            catch (err) {
                return Promise.reject('CloseConnection command failed: ' +
                    'close ' +
                    dbName +
                    ' failed ' +
                    err);
            }
        }
        // remove the connection from dictionary
        delete this._dbDict[dbName];
        return Promise.resolve();
    }
    async echo(options) {
        const keys = Object.keys(options);
        if (!keys.includes('value')) {
            return Promise.reject('Must provide a value to echo');
        }
        const ret = {};
        ret.value = options.value;
        return Promise.resolve(ret);
    }
    async open(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Open: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            await mDB.open();
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`Open: ${err}`);
        }
    }
    async close(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Close: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            await mDB.close();
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`Close: ${err}`);
        }
    }
    async getVersion(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Open: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const version = await mDB.getVersion();
            const ret = {};
            ret.version = version;
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(`Open: ${err}`);
        }
    }
    async execute(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statements') || options.statements.length === 0) {
            return Promise.reject('Must provide raw SQL statements');
        }
        const dbName = options.database;
        const statements = options.statements;
        let transaction;
        if (!keys.includes('transaction')) {
            transaction = true;
        }
        else {
            transaction = options.transaction;
        }
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Execute: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const ret = await mDB.executeSQL(statements, transaction);
            if (ret < 0) {
                return Promise.reject('Execute failed changes < 0');
            }
            else {
                return Promise.resolve({ changes: { changes: ret } });
            }
        }
        catch (err) {
            return Promise.reject(`Execute failed: ${err}`);
        }
    }
    async executeSet(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('set') || options.set.length === 0) {
            return Promise.reject('Must provide a non-empty set of SQL statements');
        }
        const dbName = options.database;
        const setOfStatements = options.set;
        let transaction;
        if (!keys.includes('transaction')) {
            transaction = true;
        }
        else {
            transaction = options.transaction;
        }
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`ExecuteSet: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        for (const sStmt of setOfStatements) {
            if (!('statement' in sStmt) || !('values' in sStmt)) {
                return Promise.reject('ExecuteSet: Must provide a set as ' + 'Array of {statement,values}');
            }
        }
        try {
            const ret = await mDB.execSet(setOfStatements, transaction);
            if (ret < 0) {
                return Promise.reject(`ExecuteSet failed changes <0`);
            }
            else {
                return Promise.resolve({ changes: ret });
            }
        }
        catch (err) {
            return Promise.reject(`ExecuteSet failed: ${err}`);
        }
    }
    async run(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statement') || options.statement.length === 0) {
            return Promise.reject('Must provide a query statement');
        }
        if (!keys.includes('values')) {
            return Promise.reject('Must provide an Array of values');
        }
        const dbName = options.database;
        const statement = options.statement;
        const values = options.values.length > 0 ? options.values : [];
        let transaction;
        if (!keys.includes('transaction')) {
            transaction = true;
        }
        else {
            transaction = options.transaction;
        }
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Run: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const ret = await mDB.runSQL(statement, values, transaction);
            return Promise.resolve({ changes: ret });
        }
        catch (err) {
            return Promise.reject(`RUN failed: ${err} `);
        }
    }
    async query(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('statement') || options.statement.length === 0) {
            return Promise.reject('Must provide a query statement');
        }
        if (!keys.includes('values')) {
            return Promise.reject('Must provide an Array of any');
        }
        const dbName = options.database;
        const statement = options.statement;
        const values = options.values.length > 0 ? options.values : [];
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`Query: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        let ret = [];
        try {
            ret = await mDB.selectSQL(statement, values);
            return Promise.resolve({ values: ret });
        }
        catch (err) {
            return Promise.reject(`Query failed: ${err}`);
        }
    }
    async isDBExists(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('IsDBExists command failed: No available ' + 'connection for ' + dbName);
        }
        const isExists = this._uFile.isFileExists(dbName + 'SQLite.db');
        return Promise.resolve({
            result: isExists,
        });
    }
    async isDBOpen(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('isDBOpen command failed: No available ' + 'connection for ' + dbName);
        }
        const mDB = this._dbDict[dbName];
        const isOpen = await mDB.isDBOpen();
        return Promise.resolve({ result: isOpen });
    }
    async isDatabase(options) {
        const keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        const isExists = this._uFile.isFileExists(dbName + 'SQLite.db');
        return Promise.resolve({
            result: isExists,
        });
    }
    async isTableExists(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        if (!keys.includes('table')) {
            return Promise.reject('Must provide a table name');
        }
        const tableName = options.table;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('isTableExists command failed: No available ' +
                'connection for ' +
                dbName);
        }
        const mDB = this._dbDict[dbName];
        try {
            const res = await mDB.isTableExists(tableName);
            return Promise.resolve({ result: res });
        }
        catch (err) {
            return Promise.reject(`isTableExists: ${err}`);
        }
    }
    async deleteDatabase(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('deleteDatabase: No available connection for ' + `${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            await mDB.deleteDB(dbName + 'SQLite.db');
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`Delete: ${err}`);
        }
    }
    async isJsonValid(options) {
        const keys = Object.keys(options);
        if (!keys.includes('jsonstring')) {
            return Promise.reject('Must provide a json object');
        }
        const jsonStrObj = options.jsonstring;
        const jsonObj = JSON.parse(jsonStrObj);
        const isValid = this._uJson.isJsonSQLite(jsonObj);
        if (!isValid) {
            return Promise.reject('Stringify Json Object not Valid');
        }
        else {
            return Promise.resolve({ result: true });
        }
    }
    async importFromJson(options) {
        var _a;
        const keys = Object.keys(options);
        if (!keys.includes('jsonstring')) {
            return Promise.reject('Must provide a json object');
        }
        const jsonStrObj = options.jsonstring;
        const jsonObj = JSON.parse(jsonStrObj);
        const isValid = this._uJson.isJsonSQLite(jsonObj);
        if (!isValid) {
            return Promise.reject('Must provide a valid JsonSQLite Object');
        }
        const vJsonObj = jsonObj;
        const dbName = `${vJsonObj.database}SQLite.db`;
        const dbVersion = (_a = vJsonObj.version) !== null && _a !== void 0 ? _a : 1;
        //    const encrypted: boolean = vJsonObj.encrypted ?? false;
        //    const mode: string = encrypted ? 'secret' : 'no-encryption';
        // Create the database
        const mDb = new Database_1.Database(dbName, 
        /*encrypted, mode, */ dbVersion, {});
        try {
            // Open the database
            await mDb.open();
            // Import the JsonSQLite Object
            const changes = await mDb.importJson(vJsonObj);
            // Close the database
            await mDb.close();
            return Promise.resolve({ changes: { changes: changes } });
        }
        catch (err) {
            return Promise.reject(`ImportFromJson: ${err}`);
        }
    }
    async exportToJson(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('jsonexportmode')) {
            return Promise.reject('Must provide a json export mode');
        }
        const dbName = options.database;
        const exportMode = options.jsonexportmode;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('exportToJson: No available connection for ' + `${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const ret = await mDB.exportJson(exportMode);
            const keys = Object.keys(ret);
            if (keys.includes('message')) {
                return Promise.reject(`exportToJson: ${ret.message}`);
            }
            else {
                return Promise.resolve({ export: ret });
            }
        }
        catch (err) {
            return Promise.reject(`exportToJson: ${err}`);
        }
    }
    async createSyncTable(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject('CreateSyncTable: No available connection for ' + `${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const ret = await mDB.createSyncTable();
            return Promise.resolve({ changes: { changes: ret } });
        }
        catch (err) {
            return Promise.reject(`createSyncTable: ${err}`);
        }
    }
    async setSyncDate(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('syncdate')) {
            return Promise.reject('Must provide a synchronization date');
        }
        const dbName = options.database;
        const syncDate = options.syncdate;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`SetSyncDate: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            await mDB.setSyncDate(syncDate);
            return Promise.resolve();
        }
        catch (err) {
            return Promise.reject(`SetSyncDate: ${err}`);
        }
    }
    async getSyncDate(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        const dbName = options.database;
        keys = Object.keys(this._dbDict);
        if (!keys.includes(dbName)) {
            return Promise.reject(`GetSyncDate: No available connection for ${dbName}`);
        }
        const mDB = this._dbDict[dbName];
        try {
            const ret = await mDB.getSyncDate();
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(`GetSyncDate: ${err}`);
        }
    }
    async addUpgradeStatement(options) {
        let keys = Object.keys(options);
        if (!keys.includes('database')) {
            return Promise.reject('Must provide a database name');
        }
        if (!keys.includes('upgrade')) {
            return Promise.reject('Must provide an upgrade statement');
        }
        const dbName = options.database;
        const upgrade = options.upgrade[0];
        keys = Object.keys(upgrade);
        if (!keys.includes('fromVersion') ||
            !keys.includes('toVersion') ||
            !keys.includes('statement')) {
            return Promise.reject('Must provide an upgrade capSQLiteVersionUpgrade Object');
        }
        if (typeof upgrade.fromVersion != 'number') {
            return Promise.reject('ugrade.fromVersion must be a number');
        }
        const upgVDict = {};
        upgVDict[upgrade.fromVersion] = upgrade;
        this._versionUpgrades[dbName] = upgVDict;
        return Promise.resolve();
    }
    async copyFromAssets(options) {
        const keys = Object.keys(options);
        const mOverwrite = keys.includes('overwrite') ? options.overwrite : true;
        // check if the assets/database folder exists
        const assetsDbPath = this._uFile.getAssetsDatabasesPath();
        const res = this._uFile.isPathExists(assetsDbPath);
        if (res) {
            // get the database files
            const dbList = await this._uFile.getFileList(assetsDbPath);
            // loop through the database files
            dbList.forEach(async (db) => {
                if (db.substring(db.length - 3) === '.db') {
                    // for each copy the file to the Application database folder
                    await this._uFile.copyFromAssetToDatabase(db, mOverwrite);
                }
                if (db.substring(db.length - 4) === '.zip') {
                    await this._uFile.unzipDatabase(db, mOverwrite);
                }
            });
            return Promise.resolve();
        }
        else {
            return Promise.reject('CopyFromAssets: assets/databases folder does not exist');
        }
    }
    async getDatabaseList() {
        // get the database folder
        const pathDatabase = this._uFile.getDatabasesPath();
        // get the list of databases
        const files = await this._uFile.getFileList(pathDatabase);
        if (files.length > 0) {
            return Promise.resolve({ values: files });
        }
        else {
            return Promise.reject(`isTableExists: No databases found`);
        }
    }
    async getMigratableDbList(options) {
        console.log('getCordovaDbList', options);
        return Promise.reject('Method not implemented.');
    }
    async addSQLiteSuffix(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async deleteOldDatabases(options) {
        console.log(`${JSON.stringify(options)}`);
        throw new Error('Method not implemented.');
    }
    async checkConnectionsConsistency(options) {
        const keys = Object.keys(options);
        if (!keys.includes('dbNames')) {
            return Promise.reject(`Must provide a list of connection's name`);
        }
        const dbNames = options.dbNames;
        const ret = {};
        ret.result = false;
        try {
            let inConnectionsSet = new Set(Object.keys(this._dbDict));
            const outConnectionSet = new Set(dbNames);
            if (outConnectionSet.size === 0) {
                await this.resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
            if (inConnectionsSet.size < outConnectionSet.size) {
                await this.resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
            if (inConnectionsSet.size > outConnectionSet.size) {
                for (const key of inConnectionsSet) {
                    if (!Array.from(outConnectionSet.keys()).includes(key)) {
                        const opt = {};
                        opt.database = key;
                        await this.closeConnection(opt);
                    }
                }
            }
            inConnectionsSet = new Set(Object.keys(this._dbDict));
            if (inConnectionsSet.size === outConnectionSet.size) {
                const symDiffSet = await this.symmetricDifference(inConnectionsSet, outConnectionSet);
                if (symDiffSet.size === 0) {
                    ret.result = true;
                    return Promise.resolve(ret);
                }
                else {
                    await this.resetDbDict(Object.keys(this._dbDict));
                    return Promise.resolve(ret);
                }
            }
            else {
                await this.resetDbDict(Object.keys(this._dbDict));
                return Promise.resolve(ret);
            }
        }
        catch (err) {
            return Promise.reject(`CheckConnectionsConsistency: ${err}`);
        }
    }
    async resetDbDict(keys) {
        try {
            for (const key of keys) {
                const opt = {};
                opt.database = key;
                await this.closeConnection(opt);
            }
        }
        catch (err) {
            return Promise.reject(`ResetDbDict: ${err}`);
        }
    }
    async symmetricDifference(setA, setB) {
        const difference = new Set(setA);
        for (const elem of setB) {
            if (difference.has(elem)) {
                difference.delete(elem);
            }
            else {
                difference.add(elem);
            }
        }
        return Promise.resolve(difference);
    }
}
exports.CapacitorSQLite = src.CapacitorSQLite = CapacitorSQLite;

exports['default'] = src;
//# sourceMappingURL=plugin.js.map
