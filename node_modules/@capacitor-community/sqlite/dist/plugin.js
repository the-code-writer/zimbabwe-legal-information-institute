var capacitorCapacitorSQLite = (function (exports, core) {
    'use strict';

    //import { Capacitor } from '@capacitor/core';
    /**
     * SQLiteConnection Class
     */
    class SQLiteConnection {
        constructor(sqlite) {
            this.sqlite = sqlite;
            this._connectionDict = new Map();
        }
        async initWebStore() {
            try {
                await this.sqlite.initWebStore();
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async saveToStore(database) {
            try {
                await this.sqlite.saveToStore({ database });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async echo(value) {
            try {
                const res = await this.sqlite.echo({ value });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isSecretStored() {
            try {
                const res = await this.sqlite.isSecretStored();
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async setEncryptionSecret(passphrase) {
            try {
                await this.sqlite.setEncryptionSecret({ passphrase: passphrase });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async changeEncryptionSecret(passphrase, oldpassphrase) {
            try {
                await this.sqlite.changeEncryptionSecret({
                    passphrase: passphrase,
                    oldpassphrase: oldpassphrase,
                });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async addUpgradeStatement(database, fromVersion, toVersion, statement, set) {
            const upgrade = {
                fromVersion,
                toVersion,
                statement,
                set: set ? set : [],
            };
            try {
                if (database.endsWith('.db'))
                    database = database.slice(0, -3);
                await this.sqlite.addUpgradeStatement({
                    database,
                    upgrade: [upgrade],
                });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async createConnection(database, encrypted, mode, version) {
            try {
                if (database.endsWith('.db'))
                    database = database.slice(0, -3);
                await this.sqlite.createConnection({
                    database,
                    encrypted,
                    mode,
                    version,
                });
                const conn = new SQLiteDBConnection(database, this.sqlite);
                this._connectionDict.set(database, conn);
                return Promise.resolve(conn);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async closeConnection(database) {
            try {
                if (database.endsWith('.db'))
                    database = database.slice(0, -3);
                await this.sqlite.closeConnection({ database });
                this._connectionDict.delete(database);
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isConnection(database) {
            const res = {};
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            res.result = this._connectionDict.has(database);
            return Promise.resolve(res);
        }
        async retrieveConnection(database) {
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            if (this._connectionDict.has(database)) {
                const conn = this._connectionDict.get(database);
                if (typeof conn != 'undefined')
                    return Promise.resolve(conn);
                else {
                    return Promise.reject(`Connection ${database} is undefined`);
                }
            }
            else {
                return Promise.reject(`Connection ${database} does not exist`);
            }
        }
        async retrieveAllConnections() {
            return this._connectionDict;
        }
        async closeAllConnections() {
            const delDict = new Map();
            try {
                for (const database of this._connectionDict.keys()) {
                    await this.sqlite.closeConnection({ database });
                    delDict.set(database, null);
                }
                for (const database of delDict.keys()) {
                    this._connectionDict.delete(database);
                }
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async checkConnectionsConsistency() {
            try {
                const keys = [...this._connectionDict.keys()];
                const res = await this.sqlite.checkConnectionsConsistency({ dbNames: keys });
                if (!res.result)
                    this._connectionDict = new Map();
                return Promise.resolve(res);
            }
            catch (err) {
                this._connectionDict = new Map();
                return Promise.reject(err);
            }
        }
        async importFromJson(jsonstring) {
            try {
                const ret = await this.sqlite.importFromJson({ jsonstring: jsonstring });
                return Promise.resolve(ret);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isJsonValid(jsonstring) {
            try {
                const ret = await this.sqlite.isJsonValid({ jsonstring: jsonstring });
                return Promise.resolve(ret);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async copyFromAssets(overwrite) {
            const mOverwrite = overwrite != null ? overwrite : true;
            try {
                await this.sqlite.copyFromAssets({ overwrite: mOverwrite });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isDatabase(database) {
            if (database.endsWith('.db'))
                database = database.slice(0, -3);
            try {
                const res = await this.sqlite.isDatabase({ database: database });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async getDatabaseList() {
            try {
                const res = await this.sqlite.getDatabaseList();
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async getMigratableDbList(folderPath) {
            if (!folderPath || folderPath.length === 0) {
                return Promise.reject('You must provide a folder path');
            }
            try {
                const res = await this.sqlite.getMigratableDbList({
                    folderPath: folderPath,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async addSQLiteSuffix(folderPath, dbNameList) {
            const path = folderPath ? folderPath : 'default';
            const dbList = dbNameList ? dbNameList : [];
            try {
                const res = await this.sqlite.addSQLiteSuffix({
                    folderPath: path,
                    dbNameList: dbList,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async deleteOldDatabases(folderPath, dbNameList) {
            const path = folderPath ? folderPath : 'default';
            const dbList = dbNameList ? dbNameList : [];
            try {
                const res = await this.sqlite.deleteOldDatabases({
                    folderPath: path,
                    dbNameList: dbList,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    /**
     * SQLiteDBConnection Class
     */
    class SQLiteDBConnection {
        constructor(dbName, sqlite) {
            this.dbName = dbName;
            this.sqlite = sqlite;
        }
        getConnectionDBName() {
            return this.dbName;
        }
        async open() {
            try {
                await this.sqlite.open({ database: this.dbName });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async close() {
            try {
                await this.sqlite.close({ database: this.dbName });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async getVersion() {
            try {
                const version = await this.sqlite.getVersion({
                    database: this.dbName,
                });
                return Promise.resolve(version);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async execute(statements, transaction = true) {
            try {
                const res = await this.sqlite.execute({
                    database: this.dbName,
                    statements: statements,
                    transaction: transaction,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async query(statement, values) {
            let res;
            try {
                if (values && values.length > 0) {
                    res = await this.sqlite.query({
                        database: this.dbName,
                        statement: statement,
                        values: values,
                    });
                }
                else {
                    res = await this.sqlite.query({
                        database: this.dbName,
                        statement: statement,
                        values: [],
                    });
                }
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async run(statement, values, transaction = true) {
            let res;
            try {
                if (values && values.length > 0) {
                    res = await this.sqlite.run({
                        database: this.dbName,
                        statement: statement,
                        values: values,
                        transaction: transaction,
                    });
                    //        }
                }
                else {
                    res = await this.sqlite.run({
                        database: this.dbName,
                        statement: statement,
                        values: [],
                        transaction: transaction,
                    });
                }
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async executeSet(set, transaction = true) {
            try {
                const res = await this.sqlite.executeSet({
                    database: this.dbName,
                    set: set,
                    transaction: transaction,
                });
                //      }
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isExists() {
            try {
                const res = await this.sqlite.isDBExists({
                    database: this.dbName,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isTable(table) {
            try {
                const res = await this.sqlite.isTableExists({
                    database: this.dbName,
                    table: table,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async isDBOpen() {
            try {
                const res = await this.sqlite.isDBOpen({
                    database: this.dbName,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async delete() {
            try {
                await this.sqlite.deleteDatabase({ database: this.dbName });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async createSyncTable() {
            try {
                const res = await this.sqlite.createSyncTable({
                    database: this.dbName,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async setSyncDate(syncdate) {
            try {
                await this.sqlite.setSyncDate({
                    database: this.dbName,
                    syncdate: syncdate,
                });
                return Promise.resolve();
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async getSyncDate() {
            try {
                const res = await this.sqlite.getSyncDate({
                    database: this.dbName,
                });
                let retDate = '';
                if (res.syncDate > 0)
                    retDate = new Date(res.syncDate * 1000).toISOString();
                return Promise.resolve(retDate);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
        async exportToJson(mode) {
            try {
                const res = await this.sqlite.exportToJson({
                    database: this.dbName,
                    jsonexportmode: mode,
                });
                return Promise.resolve(res);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }

    const CapacitorSQLite = core.registerPlugin('CapacitorSQLite', {
        web: () => Promise.resolve().then(function () { return web; }).then(m => new m.CapacitorSQLiteWeb()),
        electron: () => window.CapacitorCustomPlatform.plugins.CapacitorSQLite,
    });

    class CapacitorSQLiteWeb extends core.WebPlugin {
        constructor() {
            super(...arguments);
            this.sqliteEl = null;
            this.isStoreOpen = false;
        }
        async initWebStore() {
            await customElements.whenDefined('jeep-sqlite');
            this.sqliteEl = document.querySelector('jeep-sqlite');
            if (this.sqliteEl != null) {
                this.sqliteEl.addEventListener('jeepSqliteImportProgress', (event) => {
                    this.notifyListeners('sqliteImportProgressEvent', event.detail);
                });
                this.sqliteEl.addEventListener('jeepSqliteExportProgress', (event) => {
                    this.notifyListeners('sqliteExportProgressEvent', event.detail);
                });
                if (!this.isStoreOpen)
                    this.isStoreOpen = await this.sqliteEl.isStoreOpen();
                return Promise.resolve();
            }
            else {
                return Promise.reject('InitWeb: this.sqliteEl is null');
            }
        }
        async saveToStore(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.saveToStore(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async echo(options) {
            if (this.sqliteEl != null) {
                const echo = await this.sqliteEl.echo(options);
                return echo;
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isSecretStored() {
            throw this.unimplemented('Not implemented on web.');
        }
        async setEncryptionSecret(options) {
            console.log('setEncryptionSecret', options);
            throw this.unimplemented('Not implemented on web.');
        }
        async changeEncryptionSecret(options) {
            console.log('changeEncryptionSecret', options);
            throw this.unimplemented('Not implemented on web.');
        }
        async createConnection(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.createConnection(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async open(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.open(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async closeConnection(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.closeConnection(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async getVersion(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.getVersion(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async checkConnectionsConsistency(options) {
            if (this.sqliteEl != null) {
                try {
                    const ret = await this.sqliteEl.checkConnectionsConsistency(options);
                    return Promise.resolve(ret);
                }
                catch (err) {
                    return Promise.reject(`${err}`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async close(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.close(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async execute(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.execute(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async executeSet(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.executeSet(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async run(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.run(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async query(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.query(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isDBExists(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.isDBExists(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isDBOpen(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.isDBOpen(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isDatabase(options) {
            if (this.sqliteEl != null) {
                if (!this.isStoreOpen)
                    this.isStoreOpen = await this.sqliteEl.isStoreOpen();
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.isDatabase(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isTableExists(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.isTableExists(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async deleteDatabase(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.deleteDatabase(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async isJsonValid(options) {
            if (this.sqliteEl != null) {
                if (!this.isStoreOpen)
                    this.isStoreOpen = await this.sqliteEl.isStoreOpen();
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.isJsonValid(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async importFromJson(options) {
            if (this.sqliteEl != null) {
                if (!this.isStoreOpen)
                    this.isStoreOpen = await this.sqliteEl.isStoreOpen();
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.importFromJson(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async exportToJson(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.exportToJson(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async createSyncTable(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.createSyncTable(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async setSyncDate(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.setSyncDate(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async getSyncDate(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.getSyncDate(options);
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async addUpgradeStatement(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.addUpgradeStatement(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async copyFromAssets(options) {
            if (this.sqliteEl != null) {
                if (this.isStoreOpen) {
                    try {
                        await this.sqliteEl.copyFromAssets(options);
                        return Promise.resolve();
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async getDatabaseList() {
            if (this.sqliteEl != null) {
                if (!this.isStoreOpen)
                    this.isStoreOpen = await this.sqliteEl.isStoreOpen();
                if (this.isStoreOpen) {
                    try {
                        const ret = await this.sqliteEl.getDatabaseList();
                        return Promise.resolve(ret);
                    }
                    catch (err) {
                        return Promise.reject(`${err}`);
                    }
                }
                else {
                    return Promise.reject(`Store "jeepSqliteStore" failed to open`);
                }
            }
            else {
                throw this.unimplemented('Not implemented on web.');
            }
        }
        async getMigratableDbList(options) {
            console.log('getMigratableDbList', options);
            throw this.unimplemented('Not implemented on web.');
        }
        async addSQLiteSuffix(options) {
            console.log('addSQLiteSuffix', options);
            throw this.unimplemented('Not implemented on web.');
        }
        async deleteOldDatabases(options) {
            console.log('deleteOldDatabases', options);
            throw this.unimplemented('Not implemented on web.');
        }
    }

    var web = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CapacitorSQLiteWeb: CapacitorSQLiteWeb
    });

    exports.CapacitorSQLite = CapacitorSQLite;
    exports.SQLiteConnection = SQLiteConnection;
    exports.SQLiteDBConnection = SQLiteDBConnection;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

}({}, capacitorExports));
//# sourceMappingURL=plugin.js.map
